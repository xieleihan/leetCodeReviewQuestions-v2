## 数组

**介绍**：在 JavaScript 中，并非只有**数字**、**字符串**和**布尔值**。前面编写
JavaScript代码时，使用的都是基本类型（简单字符串、数字和布尔值）。使用基本类型可完成很多工作，但有时候必须处理更多数据，如购物车中的所有商品、播放列表中的所有歌曲、整个产品目录等等，为此，需要更强大的工具。对于这种按顺序排列的数据，可使用JavaScript**数组**来存储。本章将介绍如何将数据加入数组、如何传递数组以及如何操作数组。

**思考**：某公司要对多个新配方的“泡泡因子”进行测试，确定各个配方都能生成多少个泡泡。下面是得到的测试数据。我们应该将这些数据都输入JavaScript，以便能够编写代码来
进行分析。但数据很多，如何编写处理这些数据的代码呢？
![泡泡公司](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAegHaAAJcKRPHyso802.png?token=null&ts=null)

我们已经学习过使用JavaScript来表示单个值，如字符串、数字和布尔值，但如何表示多个值呢？JavaScript 提供了数组数据类型。数组是一种可存储很多值的JavaScript数据类型。下面的JavaScript数组存储了所有的泡泡因子得分：

```
// 这里总共有10个值，它们组合在一起，存储在一个数组中，并被赋给变量scores。
var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54];
```





**概念**：数组就是一系列的数据集合,每一项可保存**任何类型的数据**,每个元素之间用逗号隔开。不同于基本数据类型，数组数据类型是**引用数据类型**，数组是一段线性分配的内存，他通过整数计算偏移并访问其中的元素。数组是一种性能出色的数据结构。

**注意**：使用 typeof 无法得到数组类型，因为JavaScript的数组其实就是**对象**。

```
typeof scores // 'Object'
```





### 数组声明

#### 数组字面量（推荐）

**介绍**：数组字面量提供了一种非常方便的创建新数组的表示法。一个数组字面量实在一对方括号`[]`中包围零个或多个用逗号分隔的值的表达式。数组字面量允许出现在任何表达式可以出现的地方。

```
var empty = [];
var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']
```





#### 使用构造函数

**介绍**：javascript提供了 `Array` 构造函数，可以通过new关键字创建数组的示例，我们不推荐使用该方法创建数组

```
var empty = new Array()

var numbers = new Array('zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine')
```



#### 访问/修改数组元素

**介绍**：数组的第一个值将获得属性名’0’,第二个值将获得属性名’1’,以此类推。我们一般称数组的属性名为**数组的索引下标**。数组的每个元素都有索引，这是你访问和修改数组中值的钥匙。

- 访问数组元素：我们可以通过每一项数据对应的索引下标访问对应的数组元素。只需要在数组变量名后面加上用方括号括起的索引；

**语法**：

```
数组[下标]
```





**例子**：

```
var empty = [];

var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']

empty[1] // undefined

numbers[0] // 'zero'

numbers[3] // 'three'
```





- 修改数组元素：同样使用数组索引来修改数组中的值。

**语法**：

```
数组[下标] = "新值";
```





**注意**：若当前数组没有此索引将会把值作为新的元素添加到数组指定索引上。

**例子**：

```
var empty = [];
empty[0] = 'hello' // ['hello']
empty[2] = 'world' // ['hello',,'world']


var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']

numbers[3] = 'san' // ['zero', 'one', 'two', 'san', 'four', 'five', 'six', 'seven', 'eight', 'nine']
```





#### 长度

**概念**：每个数组都有一个 `length` 属性，指出了数组中当前包含了多少个元素。

```
var empty = []

empty.length // 0

var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']

numbers.length // 10
```



**注意**：

1. length属性的值实际上是这个数组的最大下标值索引元素下标值加上1，他不一定等于数组里属性的个数。

```
var myArray = []
myArray.length // 0

myArray[10000] = true
myArray.length // 10001
```





1. 你可以直接设置length的值，设置更大的length不会给数组分配更多的空间。而把length设小将导致所有下标大于等于新length的属性被删除

```
var numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']

number.length = 3 // ['zero', 'one', 'two']
```





### 数组的遍历

**介绍**：数组的遍历就是操作数组中的每一个数组元素，也可以理解数组遍历就是把每个元素从头到尾都访问一次。为此我们需要依次输出索引0、1、2的值直到达到数组最后一个索引。

- while循环输出所有的值
	**介绍**: 提到遍历我们第一时间想到的应该是while语句,因为它是JavaScript中最通用的循环结
	构。

```
var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54, 48, 69,
34, 55, 51, 52, 44, 51, 69, 64, 66, 55, 52, 61,
46, 31, 57, 52, 44, 18, 41, 53, 55, 61, 51, 44];

// 创建一个用于存储当前索引的变量。
var i = 0;

// 只要索引小于数组的长度，就继续循环。
while (i < scores.length) {
    console.log(scores[i]); // 使用console.log输出这个当前索引项数据。

    i++ // 最后，在再次循环前将索引加1。
}
```





- for循环
	**介绍**: for循环是一种更好的数组迭代方式，它的功能与while循环功能基本相同，但是for循环使用起来通常更方便些。

```
var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54, 48, 69,
34, 55, 51, 52, 44, 51, 69, 64, 66, 55, 52, 61,
46, 31, 57, 52, 44, 18, 41, 53, 55, 61, 51, 44];


// 我们将索引的初始化， 条件测试， 循环完毕更新数据都写入到for语句中
for (var i = 0; i < scores.length; i++) {
    //  只要索引小于数组的长度，就继续循环。
    console.log(scores[i]); // 使用console.log输出这个当前索引项数据。

}
```





**思考**：为什么 for 循环是更好的迭代数组的方法？

**因为**：使用while循环时，必须使用单独的语句来初始化和递增计数器。大刀阔斧地修改代码时，如果不小心移动或删除了这些语句，可能带来极其糟糕的后果。使用for循环时，这些代码都封装在for语句中，代码更加清楚，很难不小心修改或删除它们。

## 「课堂练习」

**找出所给数组数据中成绩最好的值以及他的下标**

> 要求：
>
> 遍历数组找出所提供数组中成绩最好的那一项并输出其所在数组的下标
>
> 部分代码：

```
var scores = [60, 50, 60, 58, 54, 54,
58, 50, 52, 54, 48, 69,
34, 55, 51, 52, 44, 51,
69, 64, 66, 55, 52, 61,
46, 31, 57, 52, 44, 18,
41, 53, 55, 61, 51, 44];
var highScore = _____; 
var output;

// 这里添加循环比较代码

console.log("通过检测: " + output); // 通过检测:  第 n 项成绩最高
console.log("最高成绩为？: " + _____________);
```





- for in循环枚举
	**介绍**：for in语句可以用来遍历一个数组的所有属性。遗憾的是for in无法保证属性的顺序，而大多数需要遍历数组的场合都期望按照阿拉伯数组顺序来产生元素。并且，此方法可能从**原型链**中得到意外的属性产生不必要的问题。所以不推荐此方法遍历数组。

	> 原型链的相关概念我们会在后续面向对象中具体讲解。

	**语法**：

	```
	for (变量 in 数组对象)
	{
	    // 在此执行代码
	}
	```

	

	

	**例子**：

	```
	var numbers =  ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',    'nine']
	
	  // 声明一个用来存储每次中数组中遍历元素的变量
	  var num;
	
	  // 使用for in语句，数组中每一项的值都会遍历的赋值给变量num
	  for (num in numbers) {
	 
	  console.log(num; // 使用console.log输出遍历的数据。
	
	  }
	```

	

	

### 排序算法

**思考**：现在我有一组每一项存放着Number数据类型的数组`[27,13,55,22,9,16,32,5,16]`，若现在我需要得到一个上述数组升序排列或降序排列的新数组该如何实现？

**答**：如果要解决上述问题我们就需要使用**排序算法**。

**介绍**：排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。

#### 冒泡排序

**概念**：算法是把较小的元素往前调或者把较大的元素往后调。这种方法主要是通过对相邻两个元素进行大小的比较，根据比较结果和算法规则对该二元素的位置进行交换，这样逐个依次进行比较和交换，就能达到排序目的。冒泡排序的基本思想是，首先将第1个和第2个记录的关键字比较大小，如果是逆序的，就将这两个记录进行交换，再对第2个和第3个记录的关键字进行比较，依次类推，重复进行上述计算，直至完成第(n一1)个和第n个记录的关键字之间的比较，此后，再按照上述过程进行第2次、第3次排序，直至整个序列有序为止。

![冒泡排序原理](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAWnkKAAFgtsEKoVo462.jpg?token=null&ts=null)

**注意**：冒泡排序中，当相邻两个元素大小一致时，这一步操作就不需要交换位置，因此也说明冒泡排序是一种严格的稳定排序算法，它不改变序列中相同元素之间的相对位置关系。

**例子**：

```
var numbers = [25,3,16,36,30,11,42,47,39,20];
var temp;

for (var i = numbers.length; i > 0; i--) {


    for (var j = 0 ; j < i - 1; j++) {

        if(numbers[j] > numbers[j + 1]) {
           // 左边大于右边，这时交换两者的值
           // 中间变量法交换两者的值
           temp = numbers[j]

           numbers[j] = numbers[j + 1]

           numbers[j + 1] = temp
        }

   }

}
// 第一次排序 3,16,25,30,11,36,42,39,20,47

// 第二次排序  3,16,25,11,30,36,39,20,42,47

// 第三次排序  3,16,11,25,30,36,20,39,42,47

// 第四次排序 3,11,16,25,30,20,36,39,42,47

// 第五次排序  3,11,16,25,20,30,36,39,42,47

// 第六次排序  3,11,16,20,25,30,36,39,42,47

// 。。。
```





上面案例中排序过程如下图所示

![排序过程](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAXXAbAAQDdWODCXU314.gif?token=null&ts=null)

## 「课堂练习」

**使用冒泡排序将上面的案例降序排列**

> 要求：
>
> 必须使用while语句将上面的案例使用冒泡排序降序排列（从大到小）
> 部分代码：

```
var numbers = [25,3,16,36,30,11,42,47,39,20];
var temp;
```





------

#### 插入排序

**介绍**：插入排序算法是基于某序列已经有序排列的情况下，通过一次插入一个元素的方式按照原有排序方式增加元素。这种比较是从该有序序列的最末端开始执行，即要插入序列中的元素最先和有序序列中最大的元素比较，若其大于该最大元素，则可直接插入最大元素的后面即可，否则再向前一位比较查找直至找到应该插入的位置为止。插入排序的基本思想是，每次将1个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，寻找最适当的位置，直至全部记录插入完毕。

![插入排序原理](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAebFrAAEuVdllixQ548.jpg?token=null&ts=null)

**注意**：执行过程中，若遇到和插入元素相等的位置，则将要插人的元素放在该相等元素的后面，因此插入该元素后并未改变原序列的前后顺序。
**例子**：

```
var numbers = [3, 44, 38, 5, 47, 15, 36, 26, 27];

var temp;

for (var i=0; i< numbers.length; i++) {

    for (var j=i+1; j>0; j--) {
    
        if (numbers[j] < numbers[j-1]) {
           // 这里开始和左边已排好序的进行比较，如果小于前面的就换位
            temp = numbers[j]
           
            numbers[j] = numbers[j-1]
            
            numbers[j-1] = temp
            
         } else {
            // 这时候最大的已经在最右边了，没必要再和前面比了
            break
        }
    }

    console.log(numbers.toString())

}
// 第一次排序 3,44,38,5,47,15,36,26,27

// 第二次排序 3,38,44,5,47,15,36,26,27

// 第三次排序 3,5,38,44,47,15,36,26,27

// 第四次排序 3,5,15,38,44,47,36,26,27

// 第五次排序 3,5,15,36,38,44,47,26,27

// 第六次排序 3,5,15,26,36,38,44,47,27

// 第七次排序 3,5,15,26,27,36,38,44,47

// 。。。
```





上面案例中排序过程如下图所示

![插入排序过程](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAb73tAATjPHrVPaQ583.gif?token=null&ts=null)

## 「课堂练习」

**使用插入排序将上面的案例降序排列**

> 要求：
>
> 必须使用while语句将上面的案例使用插入排序降序排列（从大到小）
> 部分代码：

```
var numbers = [3, 44, 38, 5, 47, 15, 36, 26, 27];

var temp；
```





------

### 嵌套数组

**介绍**：因为数组数据类型中每一项都可以存放任意数据类型，所以数组支持在其内部存放数组数据类型。我们会根据嵌套的层级，人为的称其为“一维数组”、“二维数组”… 二维及以上也可以被称为“多维数组”。

- 一维数组：即一个数组内所有的元素的数据类型都不是

	数组类型

	，就是一维数组。

	```
	var arr = [1, 'hello', true]
	```

	1

	

- 二维数组：数组嵌套子数组，子数组中每一项都不是数组类型。访问/修改二维数组需要使用

	 

	```
	array[i][j]
	```

	形式

	```
	var arr = [
	          [1, 2, 3, 4, 5],
	          [6, 7, 8, 9, 10],
	          [11, 12, 13, 14, 15],
	          [16, 17, 18, 19, 20],
	          [21, 22, 23, 24, 25]
	      ];
	
	arr[1][2]     // 8 
	```

	

	

#### 遍历二维数组

**介绍**： 遍历二维数组需要使用两层for嵌套，第一层 for 循环遍历最外层数组的每一项子数组。第二层for循环遍历子数组中的每一项数据。

**例子**：

```
var arr = [ [11,8,35], [7,51,99] ]; 

 for(var i=0;i<arr.length;i++) { // 第一重遍历

     // arr[i]外层数组第i项子数组 ， 初始化新变量 j 用来遍历子数组的每一项下标
     for(var j=0; j < arr[i].length ; j++){ 

            console.log(arr[i][j]) 
         
         } 

    }
```





## 「课堂练习」

**根据二维数组所提供数据生成电影院座位图**

> 要求：
>
> 根据所提供二维数组数据生成电影院座位图
>
> 使用字符串拼接实现对应电影院座位元素
>
> 0 表示空座位，1 表示可选座位，2 表示已售座位，3表示已选座位
>
> 素材：![座位素材](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAeaxCAABo89npuOA326.png?token=null&ts=null)
>
> 效果：![选座效果](http://edu.yueqian.com.cn/group1/M00/04/C2/wKgP3GC26JWAXF_TAABrSleLA00736.png?token=null&ts=null)
>
> 部分代码：

```
   <style>
        /*空*/
        .seats-0 {
            display: inline-block;
            width: 60px;
            height: 60px;
        }
        /*已售*/
        .seats-2{
            display: inline-block;
            width: 60px;
            height: 60px;
            background-position: 0 -120px;
            background-image: url(./seats.png);
            background-size: 100% auto;
        }
        /*可售*/
        .seats-1 {
            display: inline-block;
            width: 60px;
            height: 60px;

            background-image: url(./seats.png);
            background-size: 100% auto;
        }
        /*已选*/
        .seats-3 {

            display: inline-block;
            width: 60px;
            height: 60px;
            background-position: 0 -60px;
            background-image: url(./seats.png);
            background-size: 100% auto;

        }
    </style>
    <script>

    var seatsArr = [
        [1,1,0,0,0,0,0,0,1,1],
        [1,1,1,1,1,1,1,1,2,2],
        [2,2,1,1,2,2,1,1,1,1],
        [1,1,3,3,1,2,2,1,1,1],
        [1,1,0,0,0,0,0,0,1,1],
        [1,1,0,1,1,1,1,0,1,1],
        [1,1,0,1,1,1,1,0,1,1]
    ];

    var result = ''

    // 代码实现

    document.write(result)

</script>
```





------

### 向数组末尾的添加新数据

**介绍**：数组的数据并不是一成不变的，在JavaScript中数组支持对其进行增删改查操作。数组具体的操作方法我们会在后面的课程中讲解，本节课程我们只学习如何向数组的末尾添加新的数据项。

1. 通过下标添加

> 我们知道在数组中给数组的已有下标项设置数据则会更新数组指定项的值，那么如果我们给大于等于当前数组length项设置数据就可以实现给数组添加数据的效果。

```
var arr = [1,2,3,4]

arr[2] = 7 // [1,2,7,4] 已存在下标项设置数据更新指定项数据

arr[length] = 9 // [1,2,7,4,9] 给大于等于当前数组length项设置数据就可以实现给数组添加数据

arr[7] = 12 // [1,2,7,4,9,,,12] 
```





1. 使用数组自身提供的push方法:往数组尾部添加一个或多个元素,该方法返回数组新长度

```
const animals = ['pigs', 'goats', 'sheep'];

const count = animals.push('cows');
console.log(count);
// output: 4
console.log(animals);
// output: Array ["pigs", "goats", "sheep", "cows"]

animals.push('chickens', 'cats', 'dogs');
console.log(animals);
//  output: Array ["pigs", "goats", "sheep", "cows", "chickens", "cats", "dogs"]
```