## 函数

**简介**：你编写过一些代码，现在该使用函数来提高效率了。通过使用函数，你可编写适用于各种不同环境的代码。这些代码可反复重用且管理起来容易得多。你还可以将通用代码抽取出来，给它指定一个简单的名称，这样就能将复杂的东西抛诸脑后，将精力放在重要的内容上。你将发现，函数不仅是脚本编写人员通往程序员的大门，还是JavaScript编程风格的核心。

**思考**：请简单地分析下面的代码。它给你什么样的感觉？并给出你自己的评价。

```
var dogName = "旺财";
var dogWeight = 23;
if (dogWeight > 20) {
 console.log(dogName + " says WOOF WOOF");
} else {
 console.log(dogName + " says woof woof");
}

dogName = "富贵";
dogWeight = 13;
if (dogWeight > 20) {
 console.log(dogName + " says WOOF WOOF");
} else {
 console.log(dogName + " says woof woof");
}

dogName = "大黄";
dogWeight = 43;
if (dogWeight > 20) {
 console.log(dogName + " says WOOF WOOF");
} else {
 console.log(dogName + " says woof woof");
}

dogName = "小白";
dogWeight = 17;
if (dogWeight > 20) {
 console.log(dogName + " says WOOF WOOF");
} else {
 console.log(dogName + " says woof woof");
}
```





> 诚然，这些代码看起来一点问题都没有.
>
> 但编写起来很繁琐，阅读起来很痛苦，而且会在需要修改时带来麻烦。
> 随着你的编程经验日益丰富，最后一个问题将更加明显：
> 随着时间的推移，所有的代码都需要修改，而上面的代码是你迟早要面对的噩梦，
> 因为你在其中反复编写了同样的逻辑。如果需要修改这种逻辑，就必须修改多个地方。另外，程序越大，需要修改的地方就会越多，因此犯错的可能性也就越大。
>
> 我们应该做的是，想办法将这样的代码提取出来，放在一个地方，以便需要时可轻松地重用它们。

**介绍**：为了减少重复的代码，JavaScript 提供**函数**让你能够给一系列代码指定名称，以便需要时反复使用它们。函数就是一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口。在任何需要执行该功能的地方调用该函数。

### 认识函数

**例子**：以上面重复的代码为例我们使用函数简化他们。上述代码中需要编写一些反复“发出叫声”的代码：在小狗较大时发出较大的叫声（显示大写的WOOF WOOF），而小狗较小时发出较小的叫声（显示小写的woof woof），我们可以将这段代码使用封装起来

```
// 函数定义以关键 字function打头。后指定函数名， 如bark
// 函数名后面紧跟一个小括号，内部指定了两个形参，用来接受提供给他的两项信息：小狗的名字和体重。
function bark(name, weight) {
    // 接下来在函数的大括号内封装复用的代码
    // 注意,下面的代码中使用了与函数形参同名的变量
    if (weight > 20) {
        console.log(name + " says WOOF WOOF");
    } else {
        console.log(name + " says woof woof"); 
    }
}
```





> 至此，你编写了一个可在代码中反复使用的函数。有了此函数我们最初的代码将被改写为如下所示

```
function bark(name, weight) {
    if (weight > 20) {
        console.log(name + " says WOOF WOOF");
    } else {
        console.log(name + " says woof woof");
    }
} 
// 现在只需调用函数bark几次，并将小狗的名字和体重传递给它即可。
bark("旺财", 23); 
bark("富贵", 13);
bark("大黄", 43);
bark("小白", 17);
```





> 我们明显的可以看到，原来复杂重复的代码一下变得简单得多了！并且解决了“在未来要修改时带来麻烦”问题，因为当需要修改时只需要找到对应的函数修改其内部封装代码就好了，无需再像以前一样找到每一处重复的代码一处处繁琐的修改。

了解函数的基本语法结构。下面来看看其工作原理：

1. 首先，我们定义了函数。我们在代码开头定义了函数bark。浏览器读取这些代码时，发现这是一个函数，进而查看函数体中的语句。浏览器知道，不应马上执行这个函数的语句，而要等到在代码的其他地方调用了这个函数时再执行它们。
2. 注意到函数是**参数化**的 `name, weight`，这意味着它被调用时将接受小狗的名字和体重。这让你能够针对任意数量的小狗调用这个函数。每次调用时，都将对传入的名字和体重应用指定的逻辑。
3. 要调用函数，只需依次指定函数名、左括号、需要传入的值（用逗号分隔）和右括号。括号内的值被称为**实参**，就函数bark而言，需要指定两个实参：狗的名字和体重。

```
bark("富贵", 13); // 这里 "富贵" 和 13 就是传入的实参
```





1. 调用函数后，函数体将完成所有的工作。知道每个形参的值（如name的值为 “富贵” ， 而weight的值为13）后，就可以执行函数体了。如同前面编写的所有代码一样，函数体
	中的语句也是按从上到下的顺序执行的。唯一的差别是，将传给函数的**实参**的值赋给了**形参** `name` 和 `weight`。
2. 函数执行完毕后,将返回到调用函数代码语句之后继续执行

## 创建函数

### 函数字面量

**介绍**：函数对象通过函数字面量来创建

**语法**：

1. 关键字声明

```
function 函数名 ([参数列表]) { 
    // 这里放函数体,函数体就是要重复执行代码块  
}
```



1. 匿名函数

```
function([参数列表]){
    // 这里放函数体,函数体就是要重复执行代码块 
}
```



1. 函数的表达式（推荐）

```
var 变量名 = function ([参数列表]){
     // 这里放函数体,函数体就是要重复执行代码块  
}
```





**例子**：

```
// 创建一个名为add的变量，并用来把两个数字相加的函数赋值给它。
var add = function (a, b) {
    return a+b;
}    
```





**概念**：函数字面量包括4个部分。

- 第1个部分是保留字`function`。

- 第2个部分是函数名，它可以被省略（匿名函数）。

	> 函数可以用它的名字来递归地调用自己。此名字也能被调试器和开发工具用来识别函数。如果没有给函数命名，比如上面这个例子，它被称为匿名函数。

- 第3个部分是包围在圆括号中的一组**零个**或**多个**参数。多个参数用逗号分隔。这些参数的名称
	将被定义为函数中的变量。它们不像普通的变量那样将被初始化为 undefined，而是在该函数被调用时初始化为实际提供的参数的值。

- 第4个部分是包围在花括号中的一组语句。这些语句是函数的主体，它们在函数被调用时执行。

**注意**：函数字面量可以出现在任何允许表达式出现的地方。函数也可以被定义在其他函数中。
一个内部函数除了可以访问自己的参数和变量，同时它也能自由访问把它嵌套在其中的父函数的参数与变量。
通过函数字面量创建的函数对象包含一个连到外部上下文的连接。这被称为闭包（我们会在后面详细讲解）。它是 JavaScript强大表现力的来源。

### 函数构造函数 (不推荐)

**概念**：与其他数据类型一样，在JavaScript中支持使用new 关键字配合 `Function`构造函数创建函数,但是我们在开发中不推荐使用该形式

**语法**：

```
var func = new Function ([arg1[, arg2[, ...argN]],] functionBody)
```





**例子**：

```
var sum = new Function('num1','num2','return num1+num2');
```





### 参数

**概念**：参数分为形式参数和实际参数， 通过参数可以让函数参数化。即你每次使用函数时都传入不同的实参，从而动态执行相关的计算。

- 形式参数：在定义函数时，函数名后面括号中的变量名称叫做“形式参数”，或者称为“形参”
- 实际参数：在调用函数时，函数名后面括号中的变量名称叫做“实际参数”，或者称为“实参”

> 你调用函数时向它传递实参，这些实参对应于函数定义中的形参。可通过实参传递任何JavaScript表达式。
> 我们一直都在使用的`alert`、`prompt`、`document.write`。都是通过函数的参数才能实现出来的有用的代码。所以不使用函数的新手并不多，只是所使用的不是自己定义的函数。

**语法**：JavaScript按值传递实参（pass-by-value），这意味着把每个实参的值复制给形参。

```
// 在定义函数时 带参数的函数声明
function sayHello(形参1, 形参2 , 形参3...) { // 可以定义任意多的形参，用逗号分隔形参前不要加var
    
    // 函数体

}

var age = 18
// 在调用函数时 传入实参
sayHello(1, '小明', age ...) // age的值被赋值给了形参3
```





**注意**：

1. 在一个函数中，参数的多少是根据功能来定义的！

2. 形参的个数可以和实参个数不匹配，在开发中我们尽量要根据实际需求去定义。

	1. 如果传入的实参不够，没有赋值的形参的值将会为undefined

	```
	 function makeTea(cups, tea) {
	     console.log("Brewing " + cups + " cups of " + tea);
	 }
	 makeTea(3); // "Brewing 3 cups of undefined"
	```

	

	

	1. 如果传递的实参太多，javaScript将忽略多余的实参

	```
	function makeTea(cups, tea) {
	     console.log("Brewing " + cups + " cups of " + tea);
	 }
	 makeTea(3, "Black Tea", "hey ma!", 42); // "Brewing 3 cups of Black Tea"
	```

	

	

	1. 函数调用时不能省略已传实参前面的实际参数,只能省略后面的实际参数;如果一定要省略前面的参数,可以传入 undefined 或者null

	```
	 function fn(a,b){
	     console.log( b ); 
	 } 
	 fn(,1) // 错误
	 fn(undefined,1)
	```

	

	

### arguments

**概念**：当函数被调用时，会得到一个“免费”配送的参数，那就是 `arguments` 数组。函数可以通过此参数访问所有它被调用时传递给它的实际参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。这使得编写一个无须指定参数个数的函数成为可能：

```
// 构造一个将大量的值相加的函数。
//  注意该函数内部定义的变量 sum 不会与函数外部定义的 sum 产生冲突。
// 该函数只会看到内部的那个变量。
function sum () {
    var result = 0
    for(var i = 0; i < arguments.length; i++) {
        result += arguments[i]
    }
    console.log(result)
}

sum(1,2,4,3,5,20,100,50,25) // 210
```





**注意**：这不是一个特别有用的模式。因为语言的一个设计错误，arguments 并不是一个真正的数组。它只是一个“类似数组”（伪数组）的对象。arguments 拥有一个 length属性，但它没有任何数组的方法。

### 返回 Return

**概念**：当一个函数被调用时，它从第一个语句开始执行，并在遇到关闭函数体的｝时结束。然后
函数把控制权交还给调用该函数的程序。`return`语句可用来使函数提前返回。当 `return` 被执行时，函数立即返回而不再执行余下的语句。一个函数总是会返回一个值。如果没有指定返回值，则返回 `undefined`。

**语法**：

```
function 函数名([参数]){
     return 需要返回的值;
}
```





**例子**：

1. ```
	// 这是函数bake，它将烤箱温度（单位为摄氏度）作为参
	function bake(celsius) {
	    var message;
	    // 它根据形参degrees存储的温度值 将一个变量设置为相应的字符串。
	    if (celsius > 500) {
	        message = "我不是核反应堆!";
	    } else if (celsius < 100) {
	        message = "我不是电热毯!";
	    } else {
	        message = "这个温度对我来说非常舒适";
	    }
	    // 这条return语句，它将message作为函数的结果返回。
	    return message;
	}
	
	// 这个函数被调用并返回时，作为结果返回的字符串将被赋给变量status。
	var status = bake(350); 
	```

	

	

2. ```
	function calculateArea(r) {
	    var area;
	    // 如果r <= 0，就从函数返回 0，而函数也将停止执行。
	    if (r <= 0) {
	        return 0;
	    } else {
	        area = 3.14 * r * r;
	        // 从函数返回面积值。这将停止执行函数，并返回指定的值。
	        return area;
	    }
	}
	// 1. 首先，我们声明了变量radius并将其初始化为5.2。
	var radius = 5.2;
	// 2. 接下来，调用函数calculateArea，并将变量 radius 作为实参传递给它
	// 3. 将 函 数 返 回 的 值 存 储 在 变 量 theArea 中。
	var theArea = calculateArea(radius);
	```

	

	

> **扩展**：如果函数调用时在前面加上了new前缀，且返回值不是一个对象，则返回 this（该新对
> 象）。

### 递归

**概念**：递归就是直接或间接的调用自身的一种函数。递归是一种强大的编程技术。他把一个问题分解为一组相似的问题，每一组都使用通用方法去解决。简单来说一个递归函数就是调用函数自身去解决它的子问题。

**注意**：在使用递归函数时一定要设置退出函数的条件，否则会发生死循环造成严重问题

**思考**：如何创建一个函数用来计算该数字的阶乘值？

**例子**：使用循环实解决阶乘问题

```
var factorial = function(n) {
    
    var result = 1;

    while(n > 0) {
        
        result *= n
        
        n--
    }

    return result;
}
```





**例子**：使用递归解决阶乘问题

```
1 function factorial(num){
2     if(!num || num <= 1){ // 满足条件跳出递归
3         return 1;
4     }else{
5         return num * factorial(num-1);
6     }
7 }  
```





**介绍**：我们将递归函数factorial展开看看他做了什么

```
// 先递进
factorial(6)
=>  6 * factorial(5)
=>  6 * (5 * factorial(4))
=>  6 * (5 * (4 * factorial(3)))
=>  6 * (5 * (4 * (3 * factorial(2))))
=>  6 * (5 * (4 * (3 * (2 * factorial(1)))))
=>  6 * (5 * (4 * (3 * (2 * 1))))
// 再回归
=>  6 * (5 * (4 * (3 * 2)))
=>  6 * (5 * (4 * 6))
=>  6 * (5 * 24)
=>  6 * 120
=>  720
```





## 「课堂练习」

**使用递归解决猴子吃桃子问题**

> 问题：
>
> 猴子n天前摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个，第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃前一天剩下的一半零一个。到 1天前早上想再吃时，发见只剩下一个桃子了。求 n 天前一共摘多少个桃子？
>
> 要求：
>
> 1. 创建 peach 函数接收 n 作为参数，n 表示猴子是几天前摘的桃子(n > 1)
> 2. 调用 peach 函数传入天数返回猴子一共吃了几个桃子
> 3. 使用递归实现该功能
>
> 运行效果：

```
peach(4) // 22

peach(10) // 1534
```





------

## 「课堂练习」

**使用递归求下标为n的斐波那契数**

> 问题：
>
> 斐波那契数列就是最前面两个数字分别是0，1 之后每一个斐波那契数字是之前两个数字的之和。即 0,1,1,2,3,5,8,13,21,34,55,89…
>
> 要求：
>
> 1. 创建 fibonacci 函数接收 n 作为参数，n 表示需要获取的斐波那契数的下标数
> 2. 调用 fibonacci 函数传入下标返回斐波那契数列中指定下标的数字
> 3. 使用递归实现该功能
>
> 部分代码：

```
var fibonacciArr = [0,1]

var fibonacci = function(n) {

   // 代码实现

}

fibonacci(4) //3

fibonacci(10) // 55
```





------

### 作用域 Scope

**介绍**：俗称’适用范围’,分 **全局作用域** 和 **局部作用域** 在编程语言中，作用域控制着变量与参数的可见性及生命周期。对程序员来说这是一项重要的服务，因为它减少了名称冲突，并且提供了自动内存管理。

**概念**：在全局作用域下的变量称为**全局变量**,在局部作用域下的变量称为**局部变量**

- 全局变量: 声明在函数外,可以在任何地方使用,作用范围比较大,称为全局变量
- 局部变量: 在函数内使用var声明的变量,只在函数中可以使用,作用范围较小,我们称之为局部变量

```
var foo = function () {
    
    var a = 3,b = 5;

    var bar = function () {
            var b = 7,c = 11;
            // 此时，a为3，b为7，c为11。
            a += b + c;
            // 此时，a为21，b为7，c为11。
            // 此时，a为3，b为5，而c还没有定义。
        }

    bar();
    // 此时，a为21，b为5。
};
```





- 大多数类C语言语法的语言都拥有块级作用域。在一个代码块中（括在一对花括号中的一
	组语句）定义的所有变量在代码块的外部是不可见的。定义在代码块中的变量在代码块执
	行结束后会被释放掉。糟糕的是，尽管JavaScript的代码块语法貌似支持块级作用域，但实际上JavaScript并不支持。之道在ES6之后JavaScript才提出了这个这个概念。（ES6相关知识我们会在后面的课程中再做讲解）
- JavaScript确实有函数作用域。那意味着定义在函数中的参数和变量在函数外部是不可见的，**而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见**。在函数作用域内声明变量最好的做法是 **在函数体的顶部声明函数中可能用到的所有变量**。

**注意**：函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。

```
var foo = function () {
    
    var a = 3,b = 5;

    var bar = function () {
            var b = 7,c = 11;
            // 此时，a为3，b为7，c为11。

            // 因为没有使用 var 声明变量的变量是全局属性
            d = 10086

            a += b + c;
            // 此时，a为21，b为7，c为11。
            // 此时，a为3，b为5，而c还没有定义。
        }
        
    bar();
    // 此时，a为21，b为5。

    console.log(d) // d是全局属性可以访问 10086 
};
```





#### 作用域链

**介绍**：函数内部能访问函数外部的变量，每个函数在定义时就形成了局部作用域,如果存在多个函数嵌套,他们之间就会建立起某种联系,直到全局作用域,这种联系称之为作用域链.当函数访问变量时,根据**就近原则**在这个作用域链中从内到外查询变量。

**就近原则**：如在函数内查找变量a

1. 使用变量a时他会现在当前函数内查找,如果当前函数有变量a则使用
2. 如果当前函数无变量a,则往父级函数查找,如果找到则使用,并停止查找
3. 如果在父级函数还是无法找到,则继续往上一级查找,以此类推,直到对顶层(全局作用域)
4. 如果还是没找到,则会报not defined错误

#### 函数的声明变量提前

**概念**：而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见，这样就导致在函数中声明一个变量的前后，你都可以直接使用它。

```
var a =10;

function test(){
    // 尽管第一个console输出在声明a之前，但它依旧能输出，并不会报错，那是因为声明统一提前，赋值原地不变。
     console.log(a); // 没有赋值的变量默认为undefined

     var a = 20;

     console.log(a) // 20

}

test(); 
```