# 排序算法

> 尽量收集各种排序算法

## 1. 冒泡排序

> 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。

### 算法步骤

比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

### 什么时候最快

当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

### 什么时候最慢

当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。

### JavaScript 代码实现

```javascript
for(var i = 0; i < arr.length - 1; i++){
    for(var j = 0 ; j < arr.length -1 -i; j++){
        if(arr[j] > arr[j + 1]){
            var temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```

## 2. 选择排序

> 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 算法步骤

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

### 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

###  JavaScript 代码实现

```javascript
var minNumIndex = 0;
for(var i = 0; i < arr.length - 1; i++){
    minNumIndex = i;
    for(var j = i + 1; j < arr.length; j++){
        if(arr[minNumIndex] > arr[j]){
            minNumIndex = j;
        }
    }
    var temp = arr[i];
    arr[i] = arr[minNumIndex];
    arr[minNumIndex] = temp;
}
```

## 3. 插入排序

> 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
>
> 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 算法步骤

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

### JavaScript 代码实现

```javascript
for(var i =0; i < arr.length; i++){
    var j = i;
    while (j > 0) {
        if (arr[j] < arr[j - 1]) {
            var temp = arr[j];
            arr[j] = arr[j - 1];
            arr[j - 1] = temp;
            j--;
        } else {
            break;
        }
    }
}
```

## 4. 希尔排序

> 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。
>
> 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
>
> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
>
> 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

### 算法步骤

选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

按增量序列个数 k，对序列进行 k 趟排序；

每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif)

![](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png)

### JavaScript 代码实现

```javascript
var arrLen = arr.length;
for (var gap = Math.floor(arrLen / 2); gap > 0; gap = Math.floor(gap / 2)) {
    // 从gap开始，逐一对每个元素进行插入排序
    for (var i = gap; i < arrLen; i++) {
        var temp = arr[i];
        var j;

        // 使用插入排序法将 arr[i] 插入到已排序的子数组中
        for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
            arr[j] = arr[j - gap];
        }
        arr[j] = temp;
    }
}
```

## 5. 归并排序

> 
> 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
>
> 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
>
> - 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
> - 自下而上的迭代；
>
> 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：
>
> > However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.
> >
> > 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。
>
> 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。
>
> 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。

### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤 3 直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。

### 动图演示

![](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

