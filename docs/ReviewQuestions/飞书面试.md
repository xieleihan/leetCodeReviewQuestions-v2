# 题目

## 不会冒泡的事件有哪些

`blur`失焦,`focus`聚焦,`load`加载,`unload`卸载,`mouseenter`鼠标进入,不冒泡,代替mouseover,`mouseleave`鼠标离开,代替`mouseout`

## mouseenter与mouseover的区别

| 特性     | mouseover             | mouseenter                         |
| -------- | --------------------- | ---------------------------------- |
| 是否冒泡 | 会冒泡                | 不会冒泡                           |
| 触发频率 | 子元素也会触发        | 只在进入目标元素本身的时候触发一次 |
| 常用于   | 事件委托,监听整个区域 | 精确监听某个元素的进入             |

## async与await实现原理

其实这个两个是语法糖来的,基于Promise+Generator实现,将异步代码写起来像同步逻辑,背后还是异步

async函数会自动返回一个promise函数,await会暂停函数的执行,直到promise`resolve`,再恢复执行并返回结果

## Proxy能监听到对象中对象的引用吗

不能,只能监听它直接包裹的对象本身，不能自动递归监听对象内部的嵌套引用。

## 如何让var [a,b] = {a:1,b:2}解构赋值成功

数组要解构赋值,必须是右边可迭代

让对象变成可迭代（加 iterator）

```javascript
const obj = {
  a: 1,
  b: 2,
  [Symbol.iterator]: function* () {
    yield this.a;
    yield this.b;
  }
};

var [a, b] = obj;
```

## bind,call,apply有什么区别,如何实现一个bind

三者,都可以改变this指向

区别,调用方式和传参

call传一个列表

apply传一个数组

bind传一个列表,返回一个新函数

```javascript
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2]);
  };
};
```



## 什么是作用域链

**作用域链**是由当前执行上下文的作用域及其所有父级作用域按嵌套关系组成的一条链，用于**解析变量标识符**。

补充下今天的面试题
```JavaScript
const data = [{ name: 10, age: 20 }, { name: 30, age: 40 }];

// 提取字段名作为第一行
const keys = Object.keys(data[0]);

// 提取每一行的值
const values = data.map(obj => keys.map(key => obj[key]));

// 合并结果
const result = [keys, ...values];

console.log(result);
```