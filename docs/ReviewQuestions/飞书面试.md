# 题目

## 不会冒泡的事件有哪些

`blur`失焦,`focus`聚焦,`load`加载,`unload`卸载,`mouseenter`鼠标进入,不冒泡,代替mouseover,`mouseleave`鼠标离开,代替`mouseout`

## mouseenter与mouseover的区别

| 特性     | mouseover             | mouseenter                         |
| -------- | --------------------- | ---------------------------------- |
| 是否冒泡 | 会冒泡                | 不会冒泡                           |
| 触发频率 | 子元素也会触发        | 只在进入目标元素本身的时候触发一次 |
| 常用于   | 事件委托,监听整个区域 | 精确监听某个元素的进入             |

## async与await实现原理

其实这个两个是语法糖来的,基于Promise+Generator实现,将异步代码写起来像同步逻辑,背后还是异步

async函数会自动返回一个promise函数,await会暂停函数的执行,直到promise`resolve`,再恢复执行并返回结果

## Proxy能监听到对象中对象的引用吗

不能,只能监听它直接包裹的对象本身，不能自动递归监听对象内部的嵌套引用。

## 如何让var [a,b] = {a:1,b:2}解构赋值成功

数组要解构赋值,必须是右边可迭代

让对象变成可迭代（加 iterator）

```javascript
const obj = {
  a: 1,
  b: 2,
  [Symbol.iterator]: function* () {
    yield this.a;
    yield this.b;
  }
};

var [a, b] = obj;
```

## bind,call,apply有什么区别,如何实现一个bind

三者,都可以改变this指向

区别,调用方式和传参

call传一个列表

apply传一个数组

bind传一个列表,返回一个新函数

```javascript
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2]);
  };
};
```



## 什么是作用域链

**作用域链**是由当前执行上下文的作用域及其所有父级作用域按嵌套关系组成的一条链，用于**解析变量标识符**。

补充下今天的面试题
```JavaScript
const data = [{ name: 10, age: 20 }, { name: 30, age: 40 }];

// 提取字段名作为第一行
const keys = Object.keys(data[0]);

// 提取每一行的值
const values = data.map(obj => keys.map(key => obj[key]));

// 合并结果
const result = [keys, ...values];

console.log(result);
```



## 写一个发布订阅模式

> 发布-订阅模式（Pub/Sub，Publish/Subscribe）是一种**设计模式**，它的主要作用是**实现模块之间的解耦**，使得**一个模块的行为不会直接影响另一个模块**。
>
> **发布者（Publisher）**：负责发消息。
>
> **订阅者（Subscriber）**：监听某些消息，一旦有消息就做出反应。
>
> **消息中心（Event Bus）**：作为中介连接发布者和订阅者。

```javascript
class PubSub {
  constructor() {
    this.events = {};
  }

  // 订阅
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  // 发布
  publish(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  // 取消订阅
  unsubscribe(event, callback) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(cb => cb !== callback);
  }

  // 清空某事件的所有订阅者
  unsubscribeAll(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }
}
```

## 🔁 一、核心区别对比表：

| 特性 / 版本 | HTTP/1.1                         | HTTP/2                 | HTTP/3                             |
| ----------- | -------------------------------- | ---------------------- | ---------------------------------- |
| 发布年份    | 1997                             | 2015                   | 2022                               |
| 传输协议    | 基于 TCP                         | 基于 TCP               | 基于 QUIC（UDP）                   |
| 多路复用    | ❌ 无，多个请求需排队（队头阻塞） | ✅ 有，单连接并发多个流 | ✅ 改进多路复用，无 TCP 队头阻塞    |
| 头部压缩    | ❌ 无，重复传递                   | ✅ 有（HPACK 压缩）     | ✅ 有（QPACK，优化版 HPACK）        |
| 二进制传输  | ❌ 文本                           | ✅ 二进制帧             | ✅ 二进制帧                         |
| 服务端推送  | ❌ 无                             | ✅ 有（Server Push）    | ✅ 有（但部分浏览器已放弃支持）     |
| 连接建立    | 单次 TCP + TLS 多次握手          | 同左                   | 更快：0-RTT，减少握手延迟          |
| 安全性支持  | 可选 TLS                         | 强烈推荐 TLS           | 强制使用 TLS（内建在 QUIC 协议中） |



------

## 🧠 二、各版本关键点详解：

### ✅ HTTP/1.1

- **问题**：
  - 每次请求都需要一个 TCP 连接（或使用长连接 keep-alive），但仍然存在**队头阻塞**。
  - 多个资源需排队加载（浏览器通常限制同一域名同时 6 个连接）。
- **特点**：
  - 明文传输为主（可选 TLS）。
  - 无多路复用。
  - 每次请求都带完整头部，冗余大。

------

### ✅ HTTP/2

- **解决了哪些问题**：
  - 支持**多路复用**：多个请求在同一个 TCP 连接中并发发送，避免阻塞。
  - **头部压缩**：使用 HPACK，减少带宽浪费。
  - 使用**二进制帧格式**：更高效、更易于解析。
- **新特性**：
  - **服务器推送（Server Push）**：可主动向客户端推送资源。
  - 强烈建议启用 TLS，但不是强制。

------

### ✅ HTTP/3（基于 QUIC）

- **最大变革**：**完全弃用 TCP，改为基于 UDP 的 QUIC 协议**。
- **优势**：
  - **连接更快**：支持 0-RTT，复用已有连接，无需重建握手。
  - **彻底消除队头阻塞**：QUIC 每个 stream 是独立的，不再受 TCP 队头阻塞影响。
  - **内置加密**：QUIC 默认启用 TLS 1.3，通信始终加密。
- **挑战**：
  - 基于 UDP，初期部署复杂，需要操作系统和中间设备支持。
  - HTTP/3 对 CDN、代理设备要求更高。