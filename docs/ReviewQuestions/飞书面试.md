# 题目

## 不会冒泡的事件有哪些

`blur`失焦,`focus`聚焦,`load`加载,`unload`卸载,`mouseenter`鼠标进入,不冒泡,代替mouseover,`mouseleave`鼠标离开,代替`mouseout`

## mouseenter与mouseover的区别

| 特性     | mouseover             | mouseenter                         |
| -------- | --------------------- | ---------------------------------- |
| 是否冒泡 | 会冒泡                | 不会冒泡                           |
| 触发频率 | 子元素也会触发        | 只在进入目标元素本身的时候触发一次 |
| 常用于   | 事件委托,监听整个区域 | 精确监听某个元素的进入             |

## async与await实现原理

其实这个两个是语法糖来的,基于Promise+Generator实现,将异步代码写起来像同步逻辑,背后还是异步

async函数会自动返回一个promise函数,await会暂停函数的执行,直到promise`resolve`,再恢复执行并返回结果

## Proxy能监听到对象中对象的引用吗

不能,只能监听它直接包裹的对象本身，不能自动递归监听对象内部的嵌套引用。

## 如何让var [a,b] = {a:1,b:2}解构赋值成功

数组要解构赋值,必须是右边可迭代

让对象变成可迭代（加 iterator）

```javascript
const obj = {
  a: 1,
  b: 2,
  [Symbol.iterator]: function* () {
    yield this.a;
    yield this.b;
  }
};

var [a, b] = obj;
```

## bind,call,apply有什么区别,如何实现一个bind

三者,都可以改变this指向

区别,调用方式和传参

call传一个列表

apply传一个数组

bind传一个列表,返回一个新函数

```javascript
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2]);
  };
};
```



## 什么是作用域链

**作用域链**是由当前执行上下文的作用域及其所有父级作用域按嵌套关系组成的一条链，用于**解析变量标识符**。

补充下今天的面试题
```JavaScript
const data = [{ name: 10, age: 20 }, { name: 30, age: 40 }];

// 提取字段名作为第一行
const keys = Object.keys(data[0]);

// 提取每一行的值
const values = data.map(obj => keys.map(key => obj[key]));

// 合并结果
const result = [keys, ...values];

console.log(result);
```



## 写一个发布订阅模式

> 发布-订阅模式（Pub/Sub，Publish/Subscribe）是一种**设计模式**，它的主要作用是**实现模块之间的解耦**，使得**一个模块的行为不会直接影响另一个模块**。
>
> **发布者（Publisher）**：负责发消息。
>
> **订阅者（Subscriber）**：监听某些消息，一旦有消息就做出反应。
>
> **消息中心（Event Bus）**：作为中介连接发布者和订阅者。

```javascript
class PubSub {
  constructor() {
    this.events = {};
  }

  // 订阅
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  // 发布
  publish(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  // 取消订阅
  unsubscribe(event, callback) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(cb => cb !== callback);
  }

  // 清空某事件的所有订阅者
  unsubscribeAll(event) {
    if (this.events[event]) {
      delete this.events[event];
    }
  }
}
```

## 🔁 一、核心区别对比表：

| 特性 / 版本 | HTTP/1.1                         | HTTP/2                 | HTTP/3                             |
| ----------- | -------------------------------- | ---------------------- | ---------------------------------- |
| 发布年份    | 1997                             | 2015                   | 2022                               |
| 传输协议    | 基于 TCP                         | 基于 TCP               | 基于 QUIC（UDP）                   |
| 多路复用    | ❌ 无，多个请求需排队（队头阻塞） | ✅ 有，单连接并发多个流 | ✅ 改进多路复用，无 TCP 队头阻塞    |
| 头部压缩    | ❌ 无，重复传递                   | ✅ 有（HPACK 压缩）     | ✅ 有（QPACK，优化版 HPACK）        |
| 二进制传输  | ❌ 文本                           | ✅ 二进制帧             | ✅ 二进制帧                         |
| 服务端推送  | ❌ 无                             | ✅ 有（Server Push）    | ✅ 有（但部分浏览器已放弃支持）     |
| 连接建立    | 单次 TCP + TLS 多次握手          | 同左                   | 更快：0-RTT，减少握手延迟          |
| 安全性支持  | 可选 TLS                         | 强烈推荐 TLS           | 强制使用 TLS（内建在 QUIC 协议中） |



------

## 🧠 二、各版本关键点详解：

### ✅ HTTP/1.1

- **问题**：
  - 每次请求都需要一个 TCP 连接（或使用长连接 keep-alive），但仍然存在**队头阻塞**。
  - 多个资源需排队加载（浏览器通常限制同一域名同时 6 个连接）。
- **特点**：
  - 明文传输为主（可选 TLS）。
  - 无多路复用。
  - 每次请求都带完整头部，冗余大。

------

### ✅ HTTP/2

- **解决了哪些问题**：
  - 支持**多路复用**：多个请求在同一个 TCP 连接中并发发送，避免阻塞。
  - **头部压缩**：使用 HPACK，减少带宽浪费。
  - 使用**二进制帧格式**：更高效、更易于解析。
- **新特性**：
  - **服务器推送（Server Push）**：可主动向客户端推送资源。
  - 强烈建议启用 TLS，但不是强制。

------

### ✅ HTTP/3（基于 QUIC）

- **最大变革**：**完全弃用 TCP，改为基于 UDP 的 QUIC 协议**。
- **优势**：
  - **连接更快**：支持 0-RTT，复用已有连接，无需重建握手。
  - **彻底消除队头阻塞**：QUIC 每个 stream 是独立的，不再受 TCP 队头阻塞影响。
  - **内置加密**：QUIC 默认启用 TLS 1.3，通信始终加密。
- **挑战**：
  - 基于 UDP，初期部署复杂，需要操作系统和中间设备支持。
  - HTTP/3 对 CDN、代理设备要求更高。



## 小米面试

错题总结:

不是html可以使用的特殊字符

&tl;这种不是合法字符的当然不可以

`>`这个现代浏览器可以,但是不推荐



JavaScript严格区分大小写，例如变量myVar与myvar会被视为不同。



JavaScript的基础数据类型（原始类型）包括：Undefined、Null、Boolean、Number、String、Symbol（ES6新增）、BigInt（ES2020新增）。NaN是Number类型的特殊值，并非独立的数据类型，且选项D中遗漏了Null，因此该选项错误。



A. parseFloat('1234blue') === 1234

解释：parseFloat('1234blue') 会将字符串解析为浮点数。由于 '1234blue' 开头是一个有效的浮点数，解析结果为 1234。因此，判断语句为 1234 === 1234，返回 true。

B. parseFloat('0xA') === 0

解释：parseFloat('0xA') 会将字符串解析为浮点数。虽然 '0xA' 是十六进制表示的字符串，但 parseFloat() 会将其解析为十进制数。因此，解析结果为 0。因此，判断语句为 0 === 0，返回 true。

C. parseFloat('22.34.5') === 22.34

解释：parseFloat('22.34.5') 会将字符串解析为浮点数。然而，由于 '22.34.5' 包含多个小数点，它无法正确解析为浮点数。因此，解析结果为 22.34，而不是 22.34.5。因此，判断语句为 22.34 === 22.34，返回 true。

D. parseFloat('0908.5') === 908.5

解释：parseFloat('0908.5') 会将字符串解析为浮点数。由于字符串以零开头，并且后面是一个有效的浮点数表示，解析结果为 908.5。因此，判断语句为 908.5 === 908.5，返回 true。

所以，A、B、C 和 D 这四个判断语句都是正确的。



引用类型的变量名和指针存在栈中，引用类型的值（也就是对象）存在堆中



\* 使用 `Array(5)`或 `new Array(5)`构造函数，这会创建一个长度为5但没有值的数组。
\* 使用 `Array.from({length: 5})`方法，这会创建一个长度为5且每个元素都是 `undefined`的数组。
\* 使用 `Array.from({length: 5}, (v, i) => i)`方法，这会创建一个长度为5且每个元素都是索引值的数组。
\* 使用 `[,,,,,]`或 `Array(,,,,,)`字面量，这会创建一个长度为5但没有值的稀疏数组。
\* 使用 `['', '', '', '', '']`或类似的字面量，这会创建一个长度为5且每个元素都是空字符串的数组。





## 小程序为什么有两个线程

第一个线程是逻辑层,主要处理JS代码,如生命周期等(运行在独立的JS引擎环境,不直接操作DOM)

另一个线程主要是视图层,主要是渲染页面的UI

| **目的**             | **描述**                                           |
| -------------------- | -------------------------------------------------- |
| **性能优化**         | 渲染和逻辑分离，防止 UI 卡顿。                     |
| **安全性更高**       | JS 层无法直接访问 DOM，增强安全性。                |
| **跨平台适配更灵活** | 后端可以统一逻辑层，只更换视图层即可兼容不同平台。 |