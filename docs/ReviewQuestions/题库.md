![leetCodeReviewQuestions](https://socialify.git.ci/xieleihan/leetCodeReviewQuestions/image?description=1&font=Source%20Code%20Pro&forks=1&issues=1&language=1&logo=https%3A%2F%2Favatars.githubusercontent.com%2Fu%2F57227318%3Fs%3D400%26u%3D0042e26f16ac9b24babe9cc6d8f659ba4167f457%26v%3D4&name=1&owner=1&pattern=Floating%20Cogs&pulls=1&stargazers=1&theme=Light)
# Leetcode刷题记录
## 两数之和

   ```javascript
   
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function(nums, target) {
       var l = nums.length; // 取到数据的长度
       var a=[]; // 新建一个变量接受数据
       // 两层for循环遍历
       for (var i = 0; i < l; ++i) {
           for (var j = i + 1; j < l; ++j) {
               if (nums[i] + nums[j] === target) {
                   a.push(i, j);
                   return a; // 在找到结果后立即返回
               }
           }
       }
       return a;
   }
   ```

## 接雨水
   ```javascript
   /**
    * @param {number[]} height
    * @return {number}
    */
   var trap = function(height) {
       var x = height.length;
       if (x == 0) {
           return 0;
       }
       
       var leftMax = [];
       var rightMax = [];
       
       leftMax[0] = height[0];
       rightMax[x - 1] = height[x - 1];
       
       // 计算左右边界最大值
       for (var i = 1; i < x; ++i) {
           leftMax[i] = Math.max(leftMax[i - 1], height[i]);
           rightMax[x - i - 1] = Math.max(rightMax[x - i], height[x - i - 1]);
       }
       
       var sum = 0;
       for (var i = 0; i < x; ++i) {
           sum += Math.min(leftMax[i], rightMax[i]) - height[i];
       }
       
       return sum;
   };
   ```

## 三数之和

下面这个不是很好,测试用例有个超过时间限制

  ```javascript

  /**
   * @param {number[]} nums
   * @return {number[][]}
   */
  var threeSum = function(nums) {
      nums.sort((a, b) => a - b); // 将数组排序
      const result = [];
      const length = nums.length;
      for (let i = 0; i < length - 2; i++) {
          // 避免重复的第一个数
          if (i > 0 && nums[i] === nums[i - 1]) {
              continue;
          }
          for (let j = i + 1; j < length - 1; j++) {
              // 避免重复的第二个数
              if (j > i + 1 && nums[j] === nums[j - 1]) {
                  continue;
              }
              for (let k = j + 1; k < length; k++) {
                  // 避免重复的第三个数
                  if (k > j + 1 && nums[k] === nums[k - 1]) {
                      continue;
                  }
                  if (nums[i] + nums[j] + nums[k] === 0) {
                      result.push([nums[i], nums[j], nums[k]]);
                  }
              }
          }
      }
      return result;
  };

  ```
改进版:*上面它的时间复杂度是O(n^3)，因为它使用了三重循环来遍历所有可能的组合。这种解法对于较大规模的输入会导致超出时间限制。一种优化思路是通过减少循环的次数来降低时间复杂度。可以通过使用双指针的方法来替代其中的一到两个循环。以下是一个优化后的解法*
  ```javascript

  /**
   * @param {number[]} nums
   * @return {number[][]}
   */
  var threeSum = function(nums) {
      nums.sort((a, b) => a - b);
      const result = [];
      const length = nums.length;
      for (let i = 0; i < length - 2; i++) {
          if (i > 0 && nums[i] === nums[i - 1]) {
              continue;
          }
          let left = i + 1;
          let right = length - 1;
          while (left < right) {
              const sum = nums[i] + nums[left] + nums[right];
              if (sum === 0) {
                  result.push([nums[i], nums[left], nums[right]]);
                  // 去重
                  while (left < right && nums[left] === nums[left + 1]) {
                      left++;
                  }
                  while (left < right && nums[right] === nums[right - 1]) {
                      right--;
                  }
                  // 移动指针
                  left++;
                  right--;
              } else if (sum < 0) {
                  left++;
              } else {
                  right--;
              }
          }
      }
      return result;
  };

  ```

## 最接近三数之和

  ```javascript
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
  var threeSumClosest = function(nums, target) {
      nums.sort((a,b)=>a - b);
      var l = nums.length;
      // 定义一个最接近的值,后续修改
      var res = nums[0] + nums[1] + nums[2];
  
      for(var i =0 ;i<l-2;i++){
          var leftPointer = i+1;
          var rightPointer = l-1;
  
          // 左指针向右,右向左 逼近
          while(leftPointer < rightPointer){
              const sum = nums[i] + nums[leftPointer] + nums[rightPointer];
              // 由于我们的一个题目的要求是要最接近值,所以,可以用绝对值的方式来判断是最合适的
              if(Math.abs(sum-target) < Math.abs(res-target)){
                  res = sum;
              }
              // 理想情况,达到预期,直接return出去
              if(sum == target){
                  return sum;
              }
              // 不然的话做出判断,指针走,再循环
              else if (sum < target){
                  leftPointer++;
              }else{
                  rightPointer--;
              }
          }
      }
      // 结果弹出
      return res;
  };
  ```

## 四数之和

  ```JavaScript
  /**
  * @param {number[]} nums
  * @param {number} target
  * @return {number[][]}
  */
  var fourSum = function (nums, target) {
  	// 跟三数之和是差不多的
  	/**  
  	 * 第一步:我们还是对数组进行排序,方便我们的双指针
  	 * 因为什么呢,遇到这种多数计算的,双指针可以更好的实现
  	 * 相比我之前的暴力解法,这种方式很好
  	 */
  	nums.sort((a, b) => a - b);
  	var res = new Array();
  	var l = nums.length;
  	// 外层遍历数组,固定第一个数
  	for (var i = 0; i < l - 3; i++) {
  	    // 如果当前的数与上一个数相等,则跳过
  	    if (i > 0 && nums[i] == nums[i - 1]) {
  	        continue;
  	    }
  	    // 二层循环,用于固定第二个数
  	    for (var j = i + 1; j < l - 2; j++) {
  	        // 跟上一个数相等的话直接跳过
  	        if (j > i + 1 && nums[j] == nums[j - 1]) {
  	            continue;
  	        }
  	
  	        // 定义左右Pointer
  	        var leftPointer = j + 1;
  	        var rightPointer = l - 1;
  	
  	        // 遍历剩下的数组,找另外两个数
  	        while (leftPointer < rightPointer) {
  	            // const sum = nums[0]+nums[1]+nums[2]+nums[3]+nums[4];
  	            // 设置当前四个数的和
  	            const sum = nums[i] + nums[j] + nums[leftPointer] + nums[rightPointer];
  	
  	            // 如果等于target
  	            if (sum == target) {
  	                // 进入数组
  	                res.push([nums[i], nums[j], nums[leftPointer], nums[rightPointer]])
  	
  	                // 跳过重复的左pointer
  	                while (leftPointer < rightPointer && nums[leftPointer] == nums[leftPointer + 1]) {
  	                    leftPointer++;
  	                }
  	                // 跳过重复的右pointer
  	                while (leftPointer < rightPointer && nums[rightPointer] == nums[rightPointer - 1]) {
  	                    rightPointer--;
  	                }
  	
  	                // 移动左右pointer
  	                leftPointer++;
  	                rightPointer--;
  	            } else if (sum < target) {
  	                // sum小于target,左pointer右移
  	                leftPointer++;
  	            }
  	            else {
  	                // 否则,右pointer左移
  	                rightPointer--;
  	            }
  	        }
  	    }
  	}
  	return res;
  };
  ```

## 移除元素
  ```javascript
  /**
   * @param {number[]} nums
   * @param {number} val
   * @return {number}
   */
  var removeElement = function(nums, val) {
  	var i = 0; // 初始化一个指针来跟踪数组中的当前位置
  	// 第一步：获取原数组的长度
  	var l = nums.length;
  	// 根据题目的要求，不能开辟新的内存空间
  	// for(var i =0;i<l;i++){
  	//  if(nums[i]==val){
  	//      // 删除数组中指定的元素
  	//      nums.splice(nums.indexOf(val), 1)
  	//   }
  	// }
  	// 上面那个有点问题，在于你删除元素的时候，i不能完全遍历到
  
  	while (i < l) { // 遍历数组
  		if (nums[i] === val) { // 如果当前元素等于要移除的值
  			nums.splice(i, 1); // 移除索引为 i 的元素
  		} else {
  			i++; // 移动到下一个元素
  		}
  	}
  	
  	return nums.length;
  	
  };
  ```

## 有效的括号

  ```javascript
  /**
   * @param {string} s
   * @return {boolean}
   */
  var isValid = function(s) {
      // 这个得用数据结构,stack(栈)的方式
      // 解题思路是这样的,当你遇到左闭合符号的时候,压入stack,
      // 当遇到右闭合的时候,将stack弹出,来比对,直到stack没有任何东西
      var stack = []; // 创建一个新栈
      for(var i =0;i<s.length;i++){
          var char = s[i];
          if(char === '{' || char === '(' || char === '['){
              stack.push(char);
          }else{
              // 上面的那个是遇到左括号的情况
              // 如果都没左括号,直接不用再比对了
              if(stack.length == 0){
                  return false;
              }
              // 弹出栈
              var right = stack.pop();
              // check
              if((char==='}' && right !=='{') || (char===')' && right !=='(') || (char===']' && right !=='[')){
                  return false;
              }
          }
      }
      // return true;
      return stack.length === 0;
  };
  ```

## 合并两个有序链表

  ```javascript
  /**
   * Definition for singly-linked list.
   * function ListNode(val, next) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.next = (next===undefined ? null : next)
   * }
   */
  /**
   * @param {ListNode} list1
   * @param {ListNode} list2
   * @return {ListNode}
   */
  var mergeTwoLists = function(list1, list2) {
      // 这道题我第一次见,但是是数据结构类型,涉及到了链表
      // 链表的特点: head,next=>head...
      var listNode = new ListNode;
      // 循环到有一个链表为null
      while(list1 != null && list2 != null){
          if(list1.val < list2.val){
              // 如果1的值小于2
              // 将next节点接在虚拟链表后面
              listNode.next = list1;
              list1 = list1.next;
          }else{
              // 反之
              listNode.next = list2;
              list2 = list2.next;
          }
          // 移动指针到虚拟链表后面
          listNode = listNode.next;
      }
      // 上面的情况并不能避免有一个链表还有的情况
      // 做个处理,将剩下的一个接到虚拟链表里
      if(list1 != null){
          listNode.next = list1;
      }else{
          listNode.next = list2;
      }
  
      // return lianbiao
      return listNode.next;
  };
  ```

  

## 括号生成

> 这个不是很会,看题解写的. 🧭:*后续需要练习这个方面*

```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    // 先生成一个数组
    var res = new Array();
    // 我们已知需要生成的对数, 用stack可以吗?
    // 不太行,因为虽然压多少知道,但是要是数组,pop就不可知了

    // 我看解法是递归,那么我们试试
    var a = (leftPointer,rightPointer,str)=>{
        if(leftPointer == n && rightPointer ==n){
            res.push(str);
            return;
        }
        if(leftPointer < n){
            a(leftPointer+1 , rightPointer, str+"(");
        }
        if(rightPointer < leftPointer){
            a(leftPointer, rightPointer+1, str+")");
        }
    };
    a(0,0,'');
    // return res;
    return res;
};
```



# 框架

   ```javascript
   ```
