![leetCodeReviewQuestions](https://socialify.git.ci/xieleihan/leetCodeReviewQuestions/image?description=1&font=Source%20Code%20Pro&forks=1&issues=1&language=1&logo=https%3A%2F%2Favatars.githubusercontent.com%2Fu%2F57227318%3Fs%3D400%26u%3D0042e26f16ac9b24babe9cc6d8f659ba4167f457%26v%3D4&name=1&owner=1&pattern=Floating%20Cogs&pulls=1&stargazers=1&theme=Light)
# Leetcode刷题记录
## 两数之和

   ```javascript
   
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function(nums, target) {
       var l = nums.length; // 取到数据的长度
       var a=[]; // 新建一个变量接受数据
       // 两层for循环遍历
       for (var i = 0; i < l; ++i) {
           for (var j = i + 1; j < l; ++j) {
               if (nums[i] + nums[j] === target) {
                   a.push(i, j);
                   return a; // 在找到结果后立即返回
               }
           }
       }
       return a;
   }
   ```

## 接雨水
   ```javascript
   /**
    * @param {number[]} height
    * @return {number}
    */
   var trap = function(height) {
       var x = height.length;
       if (x == 0) {
           return 0;
       }
       
       var leftMax = [];
       var rightMax = [];
       
       leftMax[0] = height[0];
       rightMax[x - 1] = height[x - 1];
       
       // 计算左右边界最大值
       for (var i = 1; i < x; ++i) {
           leftMax[i] = Math.max(leftMax[i - 1], height[i]);
           rightMax[x - i - 1] = Math.max(rightMax[x - i], height[x - i - 1]);
       }
       
       var sum = 0;
       for (var i = 0; i < x; ++i) {
           sum += Math.min(leftMax[i], rightMax[i]) - height[i];
       }
       
       return sum;
   };
   ```

## 三数之和

下面这个不是很好,测试用例有个超过时间限制

  ```javascript

  /**
   * @param {number[]} nums
   * @return {number[][]}
   */
  var threeSum = function(nums) {
      nums.sort((a, b) => a - b); // 将数组排序
      const result = [];
      const length = nums.length;
      for (let i = 0; i < length - 2; i++) {
          // 避免重复的第一个数
          if (i > 0 && nums[i] === nums[i - 1]) {
              continue;
          }
          for (let j = i + 1; j < length - 1; j++) {
              // 避免重复的第二个数
              if (j > i + 1 && nums[j] === nums[j - 1]) {
                  continue;
              }
              for (let k = j + 1; k < length; k++) {
                  // 避免重复的第三个数
                  if (k > j + 1 && nums[k] === nums[k - 1]) {
                      continue;
                  }
                  if (nums[i] + nums[j] + nums[k] === 0) {
                      result.push([nums[i], nums[j], nums[k]]);
                  }
              }
          }
      }
      return result;
  };

  ```
改进版:*上面它的时间复杂度是O(n^3)，因为它使用了三重循环来遍历所有可能的组合。这种解法对于较大规模的输入会导致超出时间限制。一种优化思路是通过减少循环的次数来降低时间复杂度。可以通过使用双指针的方法来替代其中的一到两个循环。以下是一个优化后的解法*
  ```javascript

  /**
   * @param {number[]} nums
   * @return {number[][]}
   */
  var threeSum = function(nums) {
      nums.sort((a, b) => a - b);
      const result = [];
      const length = nums.length;
      for (let i = 0; i < length - 2; i++) {
          if (i > 0 && nums[i] === nums[i - 1]) {
              continue;
          }
          let left = i + 1;
          let right = length - 1;
          while (left < right) {
              const sum = nums[i] + nums[left] + nums[right];
              if (sum === 0) {
                  result.push([nums[i], nums[left], nums[right]]);
                  // 去重
                  while (left < right && nums[left] === nums[left + 1]) {
                      left++;
                  }
                  while (left < right && nums[right] === nums[right - 1]) {
                      right--;
                  }
                  // 移动指针
                  left++;
                  right--;
              } else if (sum < 0) {
                  left++;
              } else {
                  right--;
              }
          }
      }
      return result;
  };

  ```

## 最接近三数之和

  ```javascript
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
  var threeSumClosest = function(nums, target) {
      nums.sort((a,b)=>a - b);
      var l = nums.length;
      // 定义一个最接近的值,后续修改
      var res = nums[0] + nums[1] + nums[2];
  
      for(var i =0 ;i<l-2;i++){
          var leftPointer = i+1;
          var rightPointer = l-1;
  
          // 左指针向右,右向左 逼近
          while(leftPointer < rightPointer){
              const sum = nums[i] + nums[leftPointer] + nums[rightPointer];
              // 由于我们的一个题目的要求是要最接近值,所以,可以用绝对值的方式来判断是最合适的
              if(Math.abs(sum-target) < Math.abs(res-target)){
                  res = sum;
              }
              // 理想情况,达到预期,直接return出去
              if(sum == target){
                  return sum;
              }
              // 不然的话做出判断,指针走,再循环
              else if (sum < target){
                  leftPointer++;
              }else{
                  rightPointer--;
              }
          }
      }
      // 结果弹出
      return res;
  };
  ```

## 四数之和

  ```JavaScript
  /**
  * @param {number[]} nums
  * @param {number} target
  * @return {number[][]}
  */
  var fourSum = function (nums, target) {
  	// 跟三数之和是差不多的
  	/**  
  	 * 第一步:我们还是对数组进行排序,方便我们的双指针
  	 * 因为什么呢,遇到这种多数计算的,双指针可以更好的实现
  	 * 相比我之前的暴力解法,这种方式很好
  	 */
  	nums.sort((a, b) => a - b);
  	var res = new Array();
  	var l = nums.length;
  	// 外层遍历数组,固定第一个数
  	for (var i = 0; i < l - 3; i++) {
  	    // 如果当前的数与上一个数相等,则跳过
  	    if (i > 0 && nums[i] == nums[i - 1]) {
  	        continue;
  	    }
  	    // 二层循环,用于固定第二个数
  	    for (var j = i + 1; j < l - 2; j++) {
  	        // 跟上一个数相等的话直接跳过
  	        if (j > i + 1 && nums[j] == nums[j - 1]) {
  	            continue;
  	        }
  	
  	        // 定义左右Pointer
  	        var leftPointer = j + 1;
  	        var rightPointer = l - 1;
  	
  	        // 遍历剩下的数组,找另外两个数
  	        while (leftPointer < rightPointer) {
  	            // const sum = nums[0]+nums[1]+nums[2]+nums[3]+nums[4];
  	            // 设置当前四个数的和
  	            const sum = nums[i] + nums[j] + nums[leftPointer] + nums[rightPointer];
  	
  	            // 如果等于target
  	            if (sum == target) {
  	                // 进入数组
  	                res.push([nums[i], nums[j], nums[leftPointer], nums[rightPointer]])
  	
  	                // 跳过重复的左pointer
  	                while (leftPointer < rightPointer && nums[leftPointer] == nums[leftPointer + 1]) {
  	                    leftPointer++;
  	                }
  	                // 跳过重复的右pointer
  	                while (leftPointer < rightPointer && nums[rightPointer] == nums[rightPointer - 1]) {
  	                    rightPointer--;
  	                }
  	
  	                // 移动左右pointer
  	                leftPointer++;
  	                rightPointer--;
  	            } else if (sum < target) {
  	                // sum小于target,左pointer右移
  	                leftPointer++;
  	            }
  	            else {
  	                // 否则,右pointer左移
  	                rightPointer--;
  	            }
  	        }
  	    }
  	}
  	return res;
  };
  ```

## 移除元素
  ```javascript
  /**
   * @param {number[]} nums
   * @param {number} val
   * @return {number}
   */
  var removeElement = function(nums, val) {
  	var i = 0; // 初始化一个指针来跟踪数组中的当前位置
  	// 第一步：获取原数组的长度
  	var l = nums.length;
  	// 根据题目的要求，不能开辟新的内存空间
  	// for(var i =0;i<l;i++){
  	//  if(nums[i]==val){
  	//      // 删除数组中指定的元素
  	//      nums.splice(nums.indexOf(val), 1)
  	//   }
  	// }
  	// 上面那个有点问题，在于你删除元素的时候，i不能完全遍历到
  
  	while (i < l) { // 遍历数组
  		if (nums[i] === val) { // 如果当前元素等于要移除的值
  			nums.splice(i, 1); // 移除索引为 i 的元素
  		} else {
  			i++; // 移动到下一个元素
  		}
  	}
  	
  	return nums.length;
  	
  };
  ```

## 有效的括号

  ```javascript
  /**
   * @param {string} s
   * @return {boolean}
   */
  var isValid = function(s) {
      // 这个得用数据结构,stack(栈)的方式
      // 解题思路是这样的,当你遇到左闭合符号的时候,压入stack,
      // 当遇到右闭合的时候,将stack弹出,来比对,直到stack没有任何东西
      var stack = []; // 创建一个新栈
      for(var i =0;i<s.length;i++){
          var char = s[i];
          if(char === '{' || char === '(' || char === '['){
              stack.push(char);
          }else{
              // 上面的那个是遇到左括号的情况
              // 如果都没左括号,直接不用再比对了
              if(stack.length == 0){
                  return false;
              }
              // 弹出栈
              var right = stack.pop();
              // check
              if((char==='}' && right !=='{') || (char===')' && right !=='(') || (char===']' && right !=='[')){
                  return false;
              }
          }
      }
      // return true;
      return stack.length === 0;
  };
  ```

## 合并两个有序链表

  ```javascript
  /**
   * Definition for singly-linked list.
   * function ListNode(val, next) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.next = (next===undefined ? null : next)
   * }
   */
  /**
   * @param {ListNode} list1
   * @param {ListNode} list2
   * @return {ListNode}
   */
  var mergeTwoLists = function(list1, list2) {
      // 这道题我第一次见,但是是数据结构类型,涉及到了链表
      // 链表的特点: head,next=>head...
      var listNode = new ListNode;
      // 循环到有一个链表为null
      while(list1 != null && list2 != null){
          if(list1.val < list2.val){
              // 如果1的值小于2
              // 将next节点接在虚拟链表后面
              listNode.next = list1;
              list1 = list1.next;
          }else{
              // 反之
              listNode.next = list2;
              list2 = list2.next;
          }
          // 移动指针到虚拟链表后面
          listNode = listNode.next;
      }
      // 上面的情况并不能避免有一个链表还有的情况
      // 做个处理,将剩下的一个接到虚拟链表里
      if(list1 != null){
          listNode.next = list1;
      }else{
          listNode.next = list2;
      }
  
      // return lianbiao
      return listNode.next;
  };
  ```

  

## 括号生成

> 这个不是很会,看题解写的. 🧭:*后续需要练习这个方面*

```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    // 先生成一个数组
    var res = new Array();
    // 我们已知需要生成的对数, 用stack可以吗?
    // 不太行,因为虽然压多少知道,但是要是数组,pop就不可知了

    // 我看解法是递归,那么我们试试
    var a = (leftPointer,rightPointer,str)=>{
        if(leftPointer == n && rightPointer ==n){
            res.push(str);
            return;
        }
        if(leftPointer < n){
            a(leftPointer+1 , rightPointer, str+"(");
        }
        if(rightPointer < leftPointer){
            a(leftPointer, rightPointer+1, str+")");
        }
    };
    a(0,0,'');
    // return res;
    return res;
};
```

## x的平方根

```javascript
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function (x) {
    var num = 0;
    if (x == 0) {
        return 0;
    }
    if (x == 1) {
        return 1;
    }
    if (x == 2 || x == 3) {
        return 1;
    }
    if (x > 1) {
        var text = x / 2;
        for (var i = 2; i <= text; i++){
            var j = i + 1;
            if (j * j == x) {
                num = j;
                break;
            }
            if (i * i <= x && j * j >x ) {
                num = i;
                break;
            }
        }
    }
    return num;
};
```

## 爬楼梯

> 这个不就是斐波那契吗,开做

```JavaScript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
    var num = fb(n);
    return num;
};
function fb(n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    return fb(n-1) + fb(n-2);
}
```

## 矩阵置零

```JavaScript
/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {
    // 首先先遍历一下有多少行
    var row = matrix.length;
    // 多少列
    var col = matrix[0].length;
    // 设置一个标签标记,找到matrix中为0 的所有行和列的数字
    var rowflag = new Array(row).fill(false);
    var colflag = new Array(col).fill(false);

    // 题目要求是要原地算法,不能return
    // 第一次遍历,是找到这个矩阵中所有含0的数,并且打上标签
    for (var i = 0; i < row; i++){
        for (var j = 0; j < col; j++){
            if (matrix[i][j] == 0) {
                rowflag[i] = true;
                colflag[j] = true;
            }
        }
    }
    // 第二次循环是对原先数组进行直接修改
    for (var i = 0; i < row; i++) {
        for (var j = 0; j < col; j++) {
            // 查询到这个函数的标签如果为true,则置0
            if (rowflag[i] || colflag[j]) {
                matrix[i][j] = 0;
            }
        }
    }
};
```

## 搜索二维矩阵

```JavaScript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {
    // 第一步,我们先设置一个布尔变量,到最后面可以return出去
    var bool = false;

    for (var i = 0; i < matrix.length; i++){
        for (var j = 0; j < matrix[i].length; j++){
            if (matrix[i][j] == target) {
                bool = true;
                return bool;
            }
        }
    }

    return bool;
};
```

## 颜色分类

```JavaScript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {

    // 这一题我给的思路就是直接使用冒泡排序
    var len = nums.length;
    for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                var temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
};
```

> 冒泡排序绝对可以,不会出错😊

## 最小覆盖子串

```JavaScript
/**
 * @param {string} s 这是原字符串
 * @param {string} t 这是我们需要在s中,找到最小的字符串
 * @return {string}
 */
var minWindow = function (s, t) {
    // 既然要return 那肯定给一个变量给他
    var str = "";

    // 这里是直接给空字符串,因为我们如果没有t在s中,找到,都不用去修改
    var slen = s.length;
    var tlen = t.length;

    // 用双指针
    var left = 0;// 左指针
    var right = 0;// 右指针

    // 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
    while (right < slen) {
        if (s[right] == t[right]) {
            right++;
        } else {
            right++;
            left++;
        }
        if (right - left == tlen) {
            str = s.substring(left, right);
        }
        if (right == slen) {
            break;
        }
    }
    while (left < slen) {
        if (s[left] == t[left]) {
            left++;
        } else {
            left++;
            right++;
        }
        if (right - left == tlen) {
            str = s.substring(left, right);
        }
        if (left == slen) {
            break;
        }
    }
    return str;
};
```

> 有点问题🚧:不要考虑我的算法

## 组合

```JavaScript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
    var result = [];

    var dfs = function (index, current) {
        if (current.length === k) {
            result.push(current.slice()); // 将当前结果加入到结果集中
            return;
        }
        for (var i = index; i <= n; i++) {
            current.push(i); // 将当前数字加入到当前组合中
            dfs(i + 1, current); // 递归处理下一个数字
            current.pop(); // 回溯，移除最后一个数字，继续尝试其他数字
        }
    };

    dfs(1, []);

    return result;
};
```

## 子集

```JavaScript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {
    // 这道题可以看到,我们输入一个数组进去,然后让我们求子集
    // 这道题用回溯算法,或者数据结构的栈
    var arr = new Array();

    var backtrack = (start, current) => {
        arr.push([...current]); // 将当前子集加入结果集

        for (let i = start; i < nums.length; i++) {
            current.push(nums[i]); // 将当前元素加入当前子集
            backtrack(i + 1, current); // 递归处理下一个元素
            current.pop(); // 回溯，移除最后一个元素，继续尝试其他元素
        }
    };

    backtrack(0, []);

    return arr;

};
```

## 单词搜索

```JavaScript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    // 这里看一下题目,可知,题目给我们一个二维矩阵,那么我们可以遍历这个二维矩阵,然后判断这个二维矩阵中是否存在这个单词,然后如果在矩阵中找不到单词,对标志置flase
    var flag = true; // 一开始是满足的
    var chars = word.split(""); // 将字符串拆分成字符数组
    // const strlen = word.substring(0, );这是切片
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[i].length; j++) {
            // 如果当前字符与单词的第一个字符相匹配，开始匹配单词
            if (board[i][j] === chars[0]) {
                flag = true; // 一开始满足
                // 遍历单词的每个字符
                for (let k = 1; k < chars.length; k++) {
                    // 如果在矩阵中找不到与单词中的字符相匹配的字符，置标志为 false
                    if (board[i][j] !== chars[k]) {
                        flag = false;
                        break;
                    }
                }
                // 如果找到了整个单词，直接返回 true
                if (flag) {
                    return true;
                }
            }
        }
    }
    return flag;
};
```

> 上面的还是有问题🚧：不过我知道问题的原因

```JavaScript
var exist = function (board, word) {
    var rows = board.length;
    var cols = board[0].length;
    
    function dfs(i, j, index) {
        // 边界情况：如果越界或者当前字符不匹配，直接返回 false
        if (i < 0 || i >= rows || j < 0 || j >= cols || board[i][j] !== word[index]) {
            return false;
        }
        // 如果已经匹配到了单词的最后一个字符，返回 true
        if (index === word.length - 1) {
            return true;
        }
        
        // 先标记当前位置已经访问过
        var temp = board[i][j];
        board[i][j] = '*';
        
        // 在上下左右四个方向继续搜索
        var found = dfs(i + 1, j, index + 1) || dfs(i - 1, j, index + 1) || dfs(i, j + 1, index + 1) || dfs(i, j - 1, index + 1);
        
        // 恢复当前位置字符，并返回搜索结果
        board[i][j] = temp;
        return found;
    }
    
    // 遍历整个矩阵，从每一个位置出发进行搜索
    for (var i = 0; i < rows; i++) {
        for (var j = 0; j < cols; j++) {
            if (dfs(i, j, 0)) {
                return true;
            }
        }
    }
    
    // 没有找到匹配的单词
    return false;
};
```

> 改进版: *我不是与矩阵中的当前字符进行比较,而是跟位置进行比较,所以应该用深度优先dfs算法*

## 最大矩形

> 给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。
>
> ![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)
>
> ```text
> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
> 输出：6
> 解释：最大矩形如上图所示。
> ```

```JavaScript
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalRectangle = function(matrix) {
    // 如果数据为空，则设置为0
    if(matrix.length == 0 || matrix[0].length == 0){
        return 0;
    }

    // 存储数据的row，col
    const row = matrix.length;
    const col = matrix[0].length;

    // 创建数据存储每一行的高度
    const height = new Array(col).fill(0);

    // 初始化面积
    var maxArea = 0;

    for (let i = 0; i < row; i++) {
        // 更新每一行对应的列的高度数组
        for (let j = 0; j < col; j++) {
            
            height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;
        }

        // 计算当前行的最大矩形面积并更新最大值
        maxArea = Math.max(maxArea, largestRectangleArea(height));
    }

    return maxArea;
};
// 处理
function largestRectangleArea(height){
    // 使用stack数据结构
    // 初始化一个空栈
    const stack = [];
    // 初始化maxArea
    var maxArea = 0;
    // 循环item
    let i = 0;
    while (i < height.length) {
        // 当前高度大于等于栈顶高度时，将当前位置入栈
        if (stack.length === 0 || height[i] >= height[stack[stack.length - 1]]) {
            // 入栈才执行i++
            stack.push(i++);
        } else {
            // 当前高度小于栈顶高度时，计算以栈顶元素为高度的矩形面积
            const top = stack.pop();
            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
            maxArea = Math.max(maxArea, height[top] * width);
            // 注意：此处不递增 i，因为当前高度未进入矩形，需要重新计算面积
        }
    }

    // 处理栈中剩余的元素
    while (stack.length > 0) {
        const top = stack.pop();
        const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;
        maxArea = Math.max(maxArea, height[top] * width);
    }

    return maxArea;
}
```

## 解码方法

> 一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：
>
> ```text
> 'A' -> "1"
> 'B' -> "2"
> ...
> 'Z' -> "26"
> ```
>
> 要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：
>
> - `"AAJF"` ，将消息分组为 `(1 1 10 6)`
> - `"KJF"` ，将消息分组为 `(11 10 6)`
>
> 注意，消息不能分组为 `(1 11 06)` ，因为 `"06"` 不能映射为 `"F"` ，这是由于 `"6"` 和 `"06"` 在映射中并不等价。
>
> 给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。
>
> 题目数据保证答案肯定是一个 **32 位** 的整数。

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function(s) {
    if(!s || s.length == 0){
        return 0;
    }
    // 新建一个数组，存放我们遍历string的每一个item
    var arr = new Array(s.length + 1).fill(0);
    arr[0] = 1;
    arr[1] = s[0] !== '0' ? 1 : 0;
    for(let i = 2; i <= s.length; i++){
        const oneDigit = parseInt(s.substring(i-1,i));
        const twoDigits = parseInt(s.substring(i-2,i));
        if(oneDigit >= 1 && oneDigit <= 9){
            arr[i] += arr[i-1];
        }
        if(twoDigits >=10 && twoDigits <= 26){
            arr[i] += arr[i-2];
        }
    }
    return arr[s.length];
};
```



## 全排列

> Q:给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    var rel = [];
    var len = nums.length;

    // 使用回溯backtrack
    var backtrack = (start) => {
        // start == len 是处理完数组再添加进去
        if(start == len){
            // Array.prototype.slice() 是对原数组的浅拷贝
            rel.push(nums.slice()); // 当前的副本的浅拷贝
            return;
        }
        // 尝试将当前数字与后面的数字交换来生成排列
        for (let i = start; i < len; i++) {
            // 交换当前数字与第 i 个数字
            [nums[start], nums[i]] = [nums[i], nums[start]];

            // 递归处理剩余数字
            backtrack(start + 1);

            // 回溯：恢复原始数组状态
            [nums[start], nums[i]] = [nums[i], nums[start]];
        }
    };

    backtrack(0); // 从0开始回溯

    return rel;
};
```

## 格雷编码

> Q:**n 位格雷码序列** 是一个由 `2n` 个整数组成的序列，其中：
>
> - 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）
> - 第一个整数是 `0`
> - 一个整数在序列中出现 **不超过一次**
> - 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
> - **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**
>
> 给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。
>
> ```text
> 示例：
> 输入：n = 2
> 输出：[0,1,3,2]
> 解释：
> [0,1,3,2] 的二进制表示是 [00,01,11,10] 。
> - 00 和 01 有一位不同
> - 01 和 11 有一位不同
> - 11 和 10 有一位不同
> - 10 和 00 有一位不同
> [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
> - 00 和 10 有一位不同
> - 10 和 11 有一位不同
> - 11 和 01 有一位不同
> - 01 和 00 有一位不同
> ```

```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    var rel = [];
    // 0长度的终止条件
    if(n == 0){
        return [0];
    }
    // 生成一个只有n-1长度的格雷编码序列（递归）
    rel = grayCode(n - 1);
    const loadingBit = 1 << (n - 1) // 当前位数的前导位

    // 将前导位添加到 n-1 位的格雷编码序列中，并倒序添加到结果中
    for(var i = rel.length -1; i >= 0; i--){
        rel.push(rel[i]|loadingBit);
    }

    return rel;
};
```

## 加油站

> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
>
> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
>
>  
>
> **示例 1:**
>
> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> **示例 2:**
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```
>
>  
>
> **提示:**
>
> - `gas.length == n`
> - `cost.length == n`
> - `1 <= n <= 105`
> - `0 <= gas[i], cost[i] <= 104`

```javascript
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
    // 设置两个数组两个长度
    var gasLen = gas.length;
    var costLen = cost.length;
    // 输出的结果
    var result = -1;

    // 计数器
    var startCount = 0
    // 油的剩余量 我们通过这个来检测是否到达下一站
    var oil = 0;
    // 油的消耗量
    var manyOil = 0

    for(var index =0 ; index < gas.length ; index++){
        oil += gas[index] - cost[index];
        manyOil += gas[index] - cost[index];

        // 如果不够去下一站,就更换起始站
        if(manyOil < 0){
            startCount = index + 1;
            // 从空罐开始
            manyOil = 0;
        }
    }

    if(oil >= 0){
        result = startCount;
    }else{
        result;
    }
    return result;
};
```

## 分发糖果

> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
> 你需要按照以下要求，给这些孩子分发糖果：
>
> - 每个孩子至少分配到 `1` 个糖果。
> - 相邻两个孩子评分更高的孩子会获得更多的糖果。
>
> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：ratings = [1,0,2]
> 输出：5
> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> ```
>
> **示例 2：**
>
> ```
> 输入：ratings = [1,2,2]
> 输出：4
> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
> ```

> 解析: 这道题看需要两个方向判断,早期的时候自己仅一个方向造成错误,现在知道,我们依题,设置一个长度,再两个方向的数组,使用一个方法先,`fill(1)`,然后,对数组中的相邻的+1,最后比较两个方向的`Math.max`

```javascript
/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
    var ratingsLen = ratings.length;
    if (ratingsLen === 0) return 0;

    var leftToRight = new Array(ratingsLen).fill(1);
    var rightToLeft = new Array(ratingsLen).fill(1);

    // 从左向右遍历，确保每个孩子的评分比左边孩子多时，分配更多糖果
    for (var i = 1; i < ratingsLen; i++) {
        if (ratings[i] > ratings[i - 1]) {
            leftToRight[i] = leftToRight[i - 1] + 1;
        }
    }

    // 从右向左遍历，确保每个孩子的评分比右边孩子多时，分配更多糖果
    for (var i = ratingsLen - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            rightToLeft[i] = rightToLeft[i + 1] + 1;
        }
    }

    // 计算每个孩子的最终糖果数量，取两个数组中的最大值
    var result = 0;
    for (var i = 0; i < ratingsLen; i++) {
        result += Math.max(leftToRight[i], rightToLeft[i]);
    }

    return result;
};
```

## 只出现一次的数字

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>
>  
>
> **示例 1 ：**
>
> ```
> 输入：nums = [2,2,1]
> 输出：1
> ```
>
> **示例 2 ：**
>
> ```
> 输入：nums = [4,1,2,1,2]
> 输出：4
> ```
>
> **示例 3 ：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 3 * 104`
> - `-3 * 104 <= nums[i] <= 3 * 104`
> - 除了某个元素只出现一次以外，其余每个元素均出现两次。

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    var numsLen = nums.length;
    for(var index = 0; index < numsLen; index++){
        var count = 0;
        // 内部循环，用于检查当前元素在数组中出现的次数
        for (var j = 0; j < nums.length; j++) {
            if (nums[index] === nums[j]) {
                count++;
            }
        }
        // 如果当前元素只出现了一次，则返回这个元素
        if (count === 1) {
            return nums[index];
        }
    }
};
```

高效解法:***使用异或***

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    var result = 0;
    for(var i = 0; i < nums.length; i++) {
        result ^= nums[i];
    }
    return result;
};
```

## 最小的数字游戏

> 你有一个下标从 **0** 开始、长度为 **偶数** 的整数数组 `nums` ，同时还有一个空数组 `arr` 。Alice 和 Bob 决定玩一个游戏，游戏中每一轮 Alice 和 Bob 都会各自执行一次操作。游戏规则如下：
>
> - 每一轮，Alice 先从 `nums` 中移除一个 **最小** 元素，然后 Bob 执行同样的操作。
> - 接着，Bob 会将移除的元素添加到数组 `arr` 中，然后 Alice 也执行同样的操作。
> - 游戏持续进行，直到 `nums` 变为空。
>
> 返回结果数组 `arr` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [5,4,2,3]
> 输出：[3,2,5,4]
> 解释：第一轮，Alice 先移除 2 ，然后 Bob 移除 3 。然后 Bob 先将 3 添加到 arr 中，接着 Alice 再将 2 添加到 arr 中。于是 arr = [3,2] 。
> 第二轮开始时，nums = [5,4] 。Alice 先移除 4 ，然后 Bob 移除 5 。接着他们都将元素添加到 arr 中，arr 变为 [3,2,5,4] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,5]
> 输出：[5,2]
> 解释：第一轮，Alice 先移除 2 ，然后 Bob 移除 5 。然后 Bob 先将 5 添加到 arr 中，接着 Alice 再将 2 添加到 arr 中。于是 arr = [5,2] 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 100`
> - `1 <= nums[i] <= 100`
> - `nums.length % 2 == 0`

🚧：这里我首先是想到使用`stack`来解决这个问题,但是后面做的时候,感觉自己多次一举的感觉,顺便浪费了空间

最好的方式先排序好,然后直接把最小的(最左边的),`shift`出来,然后`push`就行了

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var numberGame = function(nums) {
    // 结果数组
    var arr = [];

    // 先对数组进行排序，方便取出最小值
    nums.sort((a, b) => a - b);

    // 模拟游戏过程
    while (nums.length > 0) {
        // Alice 移除最小元素
        var aliceMin = nums.shift();
        // Bob 移除最小元素
        var bobMin = nums.shift();
        
        // Bob 将移除的元素添加到数组 arr 中
        arr.push(bobMin);
        // Alice 也将移除的元素添加到数组 arr 中
        arr.push(aliceMin);
    }

    return arr;
};
```

## 回文数

> 给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。
>
> 
>
> 回文数
>
> 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
>
> 
>
> - 例如，`121` 是回文，而 `123` 不是。
>
>  
>
> **示例 1：**
>
> ```
> 输入：x = 121
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：x = -121
> 输出：false
> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
> ```
>
> **示例 3：**
>
> ```
> 输入：x = 10
> 输出：false
> 解释：从右向左读, 为 01 。因此它不是一个回文数。
> ```
>
>  
>
> **提示：**
>
> - `-231 <= x <= 231 - 1`
>
>  
>
> **进阶：**你能不将整数转为字符串来解决这个问题吗？

```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    var bool = true;
    var str = x.toString()

    for (var i = 0; i < str.length / 2; i++) {
        if (str[i] !== str[str.length - 1 - i]) {
            return false;
        }
    }
    
    return bool;
};
```

## 最长公共前缀

> 编写一个函数来查找字符串数组中的最长公共前缀。
>
> 如果不存在公共前缀，返回空字符串 `""`。
>
>  
>
> **示例 1：**
>
> ```
> 输入：strs = ["flower","flow","flight"]
> 输出："fl"
> ```
>
> **示例 2：**
>
> ```
> 输入：strs = ["dog","racecar","car"]
> 输出：""
> 解释：输入不存在公共前缀。
> ```
>
>  
>
> **提示：**
>
> - `1 <= strs.length <= 200`
> - `0 <= strs[i].length <= 200`
> - `strs[i]` 仅由小写英文字母组成

```javascript
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    var strLen = strs.length;
    if(strLen == 0){
        return '';
    }
    var baseStr = strs[0]
    for(var i = 1; i < strLen; i++){
        while(strs[i].indexOf(baseStr) != 0){
            baseStr = baseStr.substring(0, baseStr.length -1);
            if(baseStr == ''){
                return '';
            }
        }
    }
    return baseStr;
};
```

## 删除有序数组中的重复项

> 给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。
>
> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：
>
> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
> - 返回 `k` 。
>
> **判题标准:**
>
> 系统会用下面的代码来测试你的题解:
>
> ```
> int[] nums = [...]; // 输入数组
> int[] expectedNums = [...]; // 长度正确的期望答案
> 
> int k = removeDuplicates(nums); // 调用
> 
> assert k == expectedNums.length;
> for (int i = 0; i < k; i++) {
>     assert nums[i] == expectedNums[i];
> }
> ```
>
> 如果所有断言都通过，那么您的题解将被 **通过**。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 3 * 104`
> - `-104 <= nums[i] <= 104`
> - `nums` 已按 **非严格递增** 排列

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    var numsLen = nums.length;
    if(numsLen == 0){
        return 0;
    }
    var index = 0;
    for(var i = 0; i < numsLen; i++){
        if(nums[i] != nums[index]){
            index++;
            nums[index] = nums[i];
        }
    }

    return index+1;
};
```

## 找出字符串中第一个匹配项的下标

> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：haystack = "sadbutsad", needle = "sad"
> 输出：0
> 解释："sad" 在下标 0 和 6 处匹配。
> 第一个匹配项的下标是 0 ，所以返回 0 。
> ```
>
> **示例 2：**
>
> ```
> 输入：haystack = "leetcode", needle = "leeto"
> 输出：-1
> 解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= haystack.length, needle.length <= 104`
> - `haystack` 和 `needle` 仅由小写英文字符组成

```javascript
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    var haystackLen = haystack.length;
    var needleLen = needle.length;
    if(needleLen == 0){
        return 0;
    }
    // testChreey:里面有个单字符的,所以最好加上等号
    for(var i = 0;i <= haystackLen - needleLen; i++){
        if(haystack.substring(i,i+needleLen) == needle){
            return i;
        }
    }

    return -1;
};
```

## 搜索插入位置

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```
>
> **示例 3:**
>
> ```
> 输入: nums = [1,3,5,6], target = 7
> 输出: 4
> ```
>
>  
>
> **提示:**
>
> - `1 <= nums.length <= 104`
> - `-10^4 <= nums[i] <= 10^4`
> - `nums` 为 **无重复元素** 的 **升序** 排列数组
> - `-10^4 <= target <= 10^4`

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    // 请必须使用时间复杂度为 O(log n) 的算法。
    // 这里我暴力解一下试试
    for(var i= 0; i< nums.length; i++){
        if(nums[i] >= target){
            return i;
        }
    }
    return nums.length
};
```

## 加一

> 给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>
>  
>
> **示例 1：**
>
> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> ```
>
> **示例 2：**
>
> ```
> 输入：digits = [4,3,2,1]
> 输出：[4,3,2,2]
> 解释：输入数组表示数字 4321。
> ```
>
> **示例 3：**
>
> ```
> 输入：digits = [0]
> 输出：[1]
> ```
>
>  
>
> **提示：**
>
> - `1 <= digits.length <= 100`
> - `0 <= digits[i] <= 9`

```javascript
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    if (digits.length == 1 && digits[0] == 0) {
        return [1];
    }

    // 从数组的最后一位开始处理
    for (var i = digits.length - 1; i >= 0; i--) {
        // 如果当前位小于9，直接加1并返回
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        // 如果当前位是9，设为0，继续循环处理前一位
        digits[i] = 0;
    }

    // 如果所有位都是9，跳出循环后需要在数组前添加1
    digits.unshift(1);
    return digits;
};
```

## 杨辉三角

> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
>  
>
> **示例 1:**
>
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>
> **示例 2:**
>
> ```
> 输入: numRows = 1
> 输出: [[1]]
> ```
>
>  
>
> **提示:**
>
> - `1 <= numRows <= 30`

🔭：*这道题可以这样想,你把三角先换成二维数组,然后靠一边去找规律.这是一个非常好的方法*

```javascript
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {
    var result = [];

    for(var i = 0;i < numRows; i++){
        // 创建每一行数组,用1去填充
        var row = new Array(i + 1).fill(1);
        // 这里初始化值不能为0
        for(var j = 1; j < i; j++){
            row[j] = result[i-1][j-1] + result[i-1][j]
        }
        // 将数组压入原先数组中
        result.push(row);
    }
    return result;
};
```

## 杨辉三角II

> 给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)
>
>  
>
> **示例 1:**
>
> ```
> 输入: rowIndex = 3
> 输出: [1,3,3,1]
> ```
>
> **示例 2:**
>
> ```
> 输入: rowIndex = 0
> 输出: [1]
> ```
>
> **示例 3:**
>
> ```
> 输入: rowIndex = 1
> 输出: [1,1]
> ```
>
>  
>
> **提示:**
>
> - `0 <= rowIndex <= 33`
>
>  
>
> **进阶：**
>
> 你可以优化你的算法到 `*O*(*rowIndex*)` 空间复杂度吗？

🔭：*运用公式,数学的方式暴力解决*

```javascript
/**
 * @param {number} rowIndex
 * @return {number[]}
 */
function jiechen(x){
    if(x == 0){
        return 1;
    }
    if(x == 1){
        return 1;
    }else{
        return x*jiechen(x-1);
    }
}
var getRow = function(rowIndex) {
    var arr = [];
    for(var i = 0; i <= rowIndex; i++){
        arr.push(jiechen(rowIndex)/(jiechen(i)*jiechen(rowIndex-i)))
    }
    return arr;
};
```

## 字符串替换

> 将一段话中所有的oldStr替换成newStr

```javascript
function replaceString(str, oldStr, newStr) {
    var newStr = str.replaceAll(oldStr, newStr);
    return newStr;
}
```

## 查找 arr1 中不在 arr2 中的元素

```javascript
function diffArray(arr1, arr2) {
    // 查找 arr1 中不在 arr2 中的元素
    var diff1 = arr1.filter(function (item) {
        return !arr2.includes(item);
    });

    // 查找 arr2 中不在 arr1 中的元素
    var diff2 = arr2.filter(function (item) {
        return !arr1.includes(item);
    });

    // 合并两个差异数组
    var newArr = diff1.concat(diff2);

    return newArr;
}
```

## 买卖股票的最佳时期

> 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。
>
> 你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
> ```
>
>  
>
> **提示：**
>
> - `1 <= prices.length <= 105`
> - `0 <= prices[i] <= 104`

```javascript
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    if(prices.length == 0){
        return 0;
    }
    var leftPoint = prices[0];
    var rightPoint = 0;
    for(var i = 1; i < prices.length; i++){
        if(prices[i] < leftPoint){
            leftPoint = prices[i];
        }else{
            var count = prices[i] - leftPoint;
            if(count > rightPoint){
                rightPoint = count;
            }
        }
    }
    return rightPoint;
};
```

🚧：*这里我一开始的思路是暴力解法,但是会超时和越界的问题,最后看了解法发现这个其实也不怎么好*

## 验证回文串

> 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。
>
> 字母和数字都属于字母数字字符。
>
> 给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入: s = "A man, a plan, a canal: Panama"
> 输出：true
> 解释："amanaplanacanalpanama" 是回文串。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "race a car"
> 输出：false
> 解释："raceacar" 不是回文串。
> ```
>
> **示例 3：**
>
> ```
> 输入：s = " "
> 输出：true
> 解释：在移除非字母数字字符之后，s 是一个空字符串 "" 。
> 由于空字符串正着反着读都一样，所以是回文串。
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 2 * 105`
> - `s` 仅由可打印的 ASCII 字符组成

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.toLowerCase();
    s = s.replace(/[^a-z0-9]/gi, '');
    let left = 0;
    let right = s.length - 1;
    
    while (left < right) {
        if (s[left] !== s[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
};
```

## 删除重复的电子邮箱

> 表: `Person`
>
> ```
> +-------------+---------+
> | Column Name | Type    |
> +-------------+---------+
> | id          | int     |
> | email       | varchar |
> +-------------+---------+
> id 是该表的主键列(具有唯一值的列)。
> 该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。
> ```
>
>  
>
> 编写解决方案 **删除** 所有重复的电子邮件，只保留一个具有最小 `id` 的唯一电子邮件。
>
> （对于 SQL 用户，请注意你应该编写一个 `DELETE` 语句而不是 `SELECT` 语句。）
>
> （对于 Pandas 用户，请注意你应该直接修改 `Person` 表。）
>
> 运行脚本后，显示的答案是 `Person` 表。驱动程序将首先编译并运行您的代码片段，然后再显示 `Person` 表。`Person` 表的最终顺序 **无关紧要** 。
>
> 返回结果格式如下示例所示。
>
>  
>
> **示例 1:**
>
> ```
> 输入: 
> Person 表:
> +----+------------------+
> | id | email            |
> +----+------------------+
> | 1  | john@example.com |
> | 2  | bob@example.com  |
> | 3  | john@example.com |
> +----+------------------+
> 输出: 
> +----+------------------+
> | id | email            |
> +----+------------------+
> | 1  | john@example.com |
> | 2  | bob@example.com  |
> +----+------------------+
> 解释: john@example.com重复两次。我们保留最小的Id = 1。
> ```

```mysql
# Write your MySQL query statement below
delete p1
from Person p1,Person p2
where p1.email = p2.email and p1.id > p2.id;
```

## 2的幂

> 给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。
>
> 如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 1
> 输出：true
> 解释：20 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 16
> 输出：true
> 解释：24 = 16
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 3
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - `-231 <= n <= 231 - 1`
>
>  
>
> **进阶：**你能够不使用循环/递归解决此问题吗？

🔭：*这道题上来直接调用方法`Math.pow(x,y)`,肯定不会有错*

```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    var bool = false;
    for(var i = 0;i < 31; i++){
        if(n === Math.pow(2,i)){
            bool = true;
        }
    }
    return bool;
};
```

先能解,再考虑优化

*官方解:*

```javascript
var isPowerOfTwo = function(n) {
    return n > 0 && (n & (n - 1)) === 0;
};
```

然后,**我不会**

## 各位相加

> 给定一个非负整数 `num`，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。
>
>  
>
> **示例 1:**
>
> ```
> 输入: num = 38
> 输出: 2 
> 解释: 各位相加的过程为：
> 38 --> 3 + 8 --> 11
> 11 --> 1 + 1 --> 2
> 由于 2 是一位数，所以返回 2。
> ```
>
> **示例 2:**
>
> ```
> 输入: num = 0
> 输出: 0
> ```
>
>  
>
> **提示：**
>
> - `0 <= num <= 231 - 1`
>
>  
>
> **进阶：**你可以不使用循环或者递归，在 `O(1)` 时间复杂度内解决这个问题吗？

🔭：*md,直接暴力解决*

```javascript
/**
 * @param {number} num
 * @return {number}
 */
function digui(num) {
    var result = 0;
    var str = num.toString()
    console.log(str)
    for (var i = 0; i < str.length; i++) {
        console.log(str[i])
        result += parseInt(str[i]);
    }
    return result;
}
var addDigits = function(num) {
    var result = 0;
    if(num == 0){
        return result;
    }
    var newNum = digui(num);
    if (newNum < 10) {
        result = newNum;
    } else {
        result = addDigits(newNum);
    }
    return result;
};
```

## 猜数字大小

> 我们正在玩猜数字游戏。猜数字游戏的规则如下：
>
> 我会从 `1` 到 `n` 随机选择一个数字。 请你猜选出的是哪个数字。
>
> 如果你猜错了，我会告诉你，我选出的数字比你猜测的数字大了还是小了。
>
> 你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有三种可能的情况：
>
> - `-1`：你猜的数字比我选出的数字大 （即 `num > pick`）。
> - `1`：你猜的数字比我选出的数字小 （即 `num < pick`）。
> - `0`：你猜的数字与我选出的数字相等。（即 `num == pick`）。
>
> 返回我选出的数字。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 10, pick = 6
> 输出：6
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1, pick = 1
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 2, pick = 1
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 231 - 1`
> - `1 <= pick <= n`

```javascript
/** 
 * Forward declaration of guess API.
 * @param {number} num   your guess
 * @return 	     -1 if num is higher than the picked number
 *			      1 if num is lower than the picked number
 *               otherwise return 0
 * var guess = function(num) {}
 */

/**
 * @param {number} n
 * @return {number}
 */
var guessNumber = function(n) {
    // 肯定不能暴力解这道题
    // 可以使用二分查找,就是每次折中查找是哪一个部分 left right
    var left = 1;
    var right = n;
    while(left <= right){
        var middle = Math.floor((left+right)/2);
        var result = guess(middle);
        if(result === 0){
            return middle;
        }else if(result === -1){
            right = middle - 1;
        }else{
            left = middle + 1;
        }
    }
    return -1;
};
```

## 赎金信

> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。
>
> 如果可以，返回 `true` ；否则返回 `false` 。
>
> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。
>
>  
>
> **示例 1：**
>
> ```
> 输入：ransomNote = "a", magazine = "b"
> 输出：false
> ```
>
> **示例 2：**
>
> ```
> 输入：ransomNote = "aa", magazine = "ab"
> 输出：false
> ```
>
> **示例 3：**
>
> ```
> 输入：ransomNote = "aa", magazine = "aab"
> 输出：true
> ```
>
>  
>
> **提示：**
>
> - `1 <= ransomNote.length, magazine.length <= 105`
> - `ransomNote` 和 `magazine` 由小写英文字母组成

```javascript
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    var ransomNoteArr = ransomNote.split("");
    var magazineArr = magazine.split("");

    for(var i= 0; i < ransomNoteArr.length; i++){
        var bool = false;
        for(var j = 0; j < magazine.length; j++){
            if(ransomNoteArr[i] === magazineArr[j]){
                magazineArr.splice(j , 1);
                bool = true;
                break;
            }
        }
        if(!bool){
            return false;
        }
    }
    return true;
};
```

## 提莫攻击

>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。
>
>当提莫攻击艾希，艾希的中毒状态正好持续 `duration` 秒。
>
>正式地讲，提莫在 `t` 发起攻击意味着艾希在时间区间 `[t, t + duration - 1]`（含 `t` 和 `t + duration - 1`）处于中毒状态。如果提莫在中毒影响结束 **前** 再次攻击，中毒状态计时器将会 **重置** ，在新的攻击之后，中毒影响将会在 `duration` 秒后结束。
>
>给你一个 **非递减** 的整数数组 `timeSeries` ，其中 `timeSeries[i]` 表示提莫在 `timeSeries[i]` 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 `duration` 。
>
>返回艾希处于中毒状态的 **总** 秒数。
>
> 
>
>**示例 1：**
>
>```
>输入：timeSeries = [1,4], duration = 2
>输出：4
>解释：提莫攻击对艾希的影响如下：
>- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
>- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。
>艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。
>```
>
>**示例 2：**
>
>```
>输入：timeSeries = [1,2], duration = 2
>输出：3
>解释：提莫攻击对艾希的影响如下：
>- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
>- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。
>艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。
>```
>
> 
>
>**提示：**
>
>- `1 <= timeSeries.length <= 104`
>- `0 <= timeSeries[i], duration <= 107`
>- `timeSeries` 按 **非递减** 顺序排列

```javascript
/**
 * @param {number[]} timeSeries
 * @param {number} duration
 * @return {number}
 */
var findPoisonedDuration = function(timeSeries, duration) {
    if(timeSeries.length === 0){
        return 0;
    }
    var temp = 0;
    for(var i = 0; i < timeSeries.length-1; i++){
        var runtime = timeSeries[i+1] - timeSeries[i];
        temp += Math.min(runtime, duration);
    }

    temp += duration;
    return temp;
};
```

## 下一个更大元素  I

> `nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。
>
> 给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。
>
> 对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。
>
> 返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出：[-1,3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [2,4], nums2 = [1,2,3,4].
> 输出：[3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。
> - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums1.length <= nums2.length <= 1000`
> - `0 <= nums1[i], nums2[i] <= 104`
> - `nums1`和`nums2`中所有整数 **互不相同**
> - `nums1` 中的所有整数同样出现在 `nums2` 中
>
>  
>
> **进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function(nums1, nums2) {
    var nums1Len = nums1.length;
    var nums2Len = nums2.length;
    var result = [];
    var temp;
    for(var i = 0; i < nums1Len; i++){
        var flag = false;
        temp = -1;
        for(var j = 0; j < nums2Len;j++){
            if(nums2[j] === nums1[i]){
                flag = true;
            }
            if(flag && nums2[j] > nums1[i]){
                temp = nums2[j];
                break;
            }
        }
        result.push(temp);
    }
    return result;
};
```

## 计数器

> 给定一个整型参数 `n`，请你编写并返回一个 `counter` 函数。这个 `counter` 函数最初返回 `n`，每次调用它时会返回前一个值加 1 的值 ( `n` , `n + 1` , `n + 2` ，等等)。
>
>  
>
> **示例 1：**
>
> ```
> 输入：
> n = 10 
> ["call","call","call"]
> 输出：[10,11,12]
> 解释：
> counter() = 10 // 第一次调用 counter()，返回 n。
> counter() = 11 // 返回上次调用的值加 1。
> counter() = 12 // 返回上次调用的值加 1。
> ```
>
> **示例 2：**
>
> ```
> 输入：
> n = -2
> ["call","call","call","call","call"]
> 输出：[-2,-1,0,1,2]
> 解释：counter() 最初返回 -2。然后在每个后续调用后增加 1。
> ```
>
>  
>
> **提示：**
>
> - `-1000 <= n <= 1000`
> - `0 <= calls.length <= 1000`
> - `calls[i] === "call"`

🔭：*因为我是JavaScript,所以使用到了闭包的知识:就是在内部作用域可以调用外部的变量*

```javascript
/**
 * @param {number} n
 * @return {Function} counter
 */
var createCounter = function(n) {
    let count = n
    return function() {
        return count++;        
    };
};

/** 
 * const counter = createCounter(10)
 * counter() // 10
 * counter() // 11
 * counter() // 12
 */
```

## 电话号码的字母组合

> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)
>
>  
>
> **示例 1：**
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> **示例 2：**
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```
>
>  
>
> **提示：**
>
> - `0 <= digits.length <= 4`
> - `digits[i]` 是范围 `['2', '9']` 的一个数字。

🔭：*题解都写出来了,记得看步骤*

```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
    if (!digits.length) return [];
    // 这道题是微软很多年前的面试题了
    // 1.首先,我们可以用下数学的方法, 笛卡尔积
    function compose(arr1, arr2) {
        // 3.做一个判断
        if (arr1.length === 0) {
            return arr2;
        }
        if (arr2.length === 0) {
            return arr1;
        }

        // 2.可以看到下面的算法可以实现,但是有问题,就是当有一个数组为空值的时候,会返回一个空
        const result = [];
        for (var i = 0; i < arr1.length; i++) {
            for (var j = 0; j < arr2.length; j++) {
                result.push(arr1[i] + arr2[j]);
            }
        }
        return result;
    }

    // 4.然后我们现在的话其实是已经做好了一个求笛卡尔积的函数,但是我们得做一个映射关系map
    // 当我们输入'2',输出来的是'abc',这样类型的才对
    // 注意,'1'没有东西,做一个稀疏数组
    const map = [, , 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];

    // 5.然后把传进来的的转换成数组
    // var result = digits.split('').map(it) => map[it]);
    // 6.组合一下
    var result = digits
        .split('')
        .map((it) => map[it])
        .reduce((r, it) => compose(r, it), []);

    // 7.最后单独处理'2'的情况
    var newArr = Array.isArray(result) ? result : result.split('');
    return newArr;
};
```

## 密钥格式化

> 给定一个许可密钥字符串 `s`，仅由字母、数字字符和破折号组成。字符串由 `n` 个破折号分成 `n + 1` 组。你也会得到一个整数 `k` 。
>
> 我们想要重新格式化字符串 `s`，使每一组包含 `k` 个字符，除了第一组，它可以比 `k` 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。
>
> 返回 *重新格式化的许可密钥* 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：S = "5F3Z-2e-9-w", k = 4
> 输出："5F3Z-2E9W"
> 解释：字符串 S 被分成了两个部分，每部分 4 个字符；
>      注意，两个额外的破折号需要删掉。
> ```
>
> **示例 2：**
>
> ```
> 输入：S = "2-5g-3-J", k = 2
> 输出："2-5G-3J"
> 解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
> ```
>
>  
>
> **提示:**
>
> - `1 <= s.length <= 105`
> - `s` 只包含字母、数字和破折号 `'-'`.
> - `1 <= k <= 104`

```JavaScript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var licenseKeyFormatting = function(s, k) {
    var str = s.replace(/-/g, "").toUpperCase();

    
    var result = [];
    var length = str.length;

    var firstLength = length % k === 0 ? k : length % k;

    result.push(str.substring(0,firstLength));
    // 遍历剩下的字符分组
    for(var i = firstLength; i < length ; i+=k){
        result.push(str.substring(i,i+k));
    }

    return result.join("-");
};
```

## 最大连续1的个数

> 给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,0,1,1,1]
> 输出：3
> 解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
> ```
>
> **示例 2:**
>
> ```
> 输入：nums = [1,0,1,1,0,1]
> 输出：2
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `nums[i]` 不是 `0` 就是 `1`.

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    var index = 0;
    var result = 0;
    for(var i = 0; i < nums.length; i++){
        if(nums[i] === 1){
            index++;
        }else{
            result = Math.max(result, index);
            index = 0;
        }
    }
    // 最后再更新一次 result
    result = Math.max(result, index);
    return result;
};
```

## 构造矩形

> 作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：
>
> 1. 你设计的矩形页面必须等于给定的目标面积。
> 2. 宽度 `W` 不应大于长度 `L` ，换言之，要求 `L >= W `。
> 3. 长度 `L` 和宽度 `W` 之间的差距应当尽可能小。
>
> 返回一个 *数组* `[L, W]`，其中 *`L` 和 `W` 是你按照顺序设计的网页的长度和宽度*。
>  
>
> **示例1：**
>
> ```
> 输入: 4
> 输出: [2, 2]
> 解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
> 但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
> ```
>
> **示例 2:**
>
> ```
> 输入: area = 37
> 输出: [37,1]
> ```
>
> **示例 3:**
>
> ```
> 输入: area = 122122
> 输出: [427,286]
> ```
>
>  
>
> **提示:**
>
> - `1 <= area <= 107`

```javascript
/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
    var width = Math.floor(Math.sqrt(area)); // 从最大的可能宽度开始
    while (area % width !== 0) {
        width--; // 直到找到一个可以整除的宽度
    }
    var length = area / width; // 对应的长度
    return [length, width];
};
```

## 斐波那契数

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n` ，请计算 `F(n)` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3
> ```
>
>  
>
> **提示：**
>
> - `0 <= n <= 30`

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function (n) {
    function fibonaci(n) {
        if (n === 0) {
            return 0;
        }
        if (n === 1) {
            return 1;
        }
        return fibonaci(n - 1) + fibonaci(n - 2);
    }
    return fibonaci(n);
};
```

## 键盘行

> 给你一个字符串数组 `words` ，只返回可以使用在 **美式键盘** 同一行的字母打印出来的单词。键盘如下图所示。
>
> **美式键盘** 中：
>
> - 第一行由字符 `"qwertyuiop"` 组成。
> - 第二行由字符 `"asdfghjkl"` 组成。
> - 第三行由字符 `"zxcvbnm"` 组成。
>
> ![American keyboard](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png)
>
>  
>
> **示例 1：**
>
> ```
> 输入：words = ["Hello","Alaska","Dad","Peace"]
> 输出：["Alaska","Dad"]
> ```
>
> **示例 2：**
>
> ```
> 输入：words = ["omk"]
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：words = ["adsdf","sfd"]
> 输出：["adsdf","sfd"]
> ```
>
>  
>
> **提示：**
>
> - `1 <= words.length <= 20`
> - `1 <= words[i].length <= 100`
> - `words[i]` 由英文字母（小写和大写字母）组成

```javascript
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function (words) {
    var result = [];
    var mapArr = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'];
    for (var i = 0; i < words.length; i++) {
        var word = words[i].toLowerCase();
        for (var j = 0; j < mapArr.length; j++) {
            var flag = true;
            for (var k = 0; k < word.length; k++) {
                if (mapArr[j].indexOf(word[k]) === -1) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                result.push(words[i]);
                break; // 一旦找到符合条件的行，跳出当前检查行的循环
            }
        }
    }
    return result;
};
```

## 七进制

> 给定一个整数 `num`，将其转化为 **7 进制**，并以字符串形式输出。
>
>  
>
> **示例 1:**
>
> ```
> 输入: num = 100
> 输出: "202"
> ```
>
> **示例 2:**
>
> ```
> 输入: num = -7
> 输出: "-10"
> ```
>
>  
>
> **提示：**
>
> - `-107 <= num <= 107`

```javascript
/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
    if (num === 0) return "0";
    var isNegative = num < 0;
    num = Math.abs(num);
    var str = '';
    var arr = [];
    var flag = true;
    while(flag){
        if(num >= 7){
            arr.push(num % 7);
            num = Math.floor(num / 7);
        }else{
            arr.push(num);
            flag = false;
        }
    }
    if (isNegative) {
        str += '-'
        for (var i = arr.length - 1; i >= 0; i--) {          
            str += arr[i];
        }
    }else{
        for (var i = arr.length - 1; i >= 0; i--) {
            str += arr[i];
        }
    }
    return str;
};
```

## 相对名次

> 给你一个长度为 `n` 的整数数组 `score` ，其中 `score[i]` 是第 `i` 位运动员在比赛中的得分。所有得分都 **互不相同** 。
>
> 运动员将根据得分 **决定名次** ，其中名次第 `1` 的运动员得分最高，名次第 `2` 的运动员得分第 `2` 高，依此类推。运动员的名次决定了他们的获奖情况：
>
> - 名次第 `1` 的运动员获金牌 `"Gold Medal"` 。
> - 名次第 `2` 的运动员获银牌 `"Silver Medal"` 。
> - 名次第 `3` 的运动员获铜牌 `"Bronze Medal"` 。
> - 从名次第 `4` 到第 `n` 的运动员，只能获得他们的名次编号（即，名次第 `x` 的运动员获得编号 `"x"`）。
>
> 使用长度为 `n` 的数组 `answer` 返回获奖，其中 `answer[i]` 是第 `i` 位运动员的获奖情况。
>
>  
>
> **示例 1：**
>
> ```
> 输入：score = [5,4,3,2,1]
> 输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
> 解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：score = [10,3,8,9,4]
> 输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
> 解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
> ```
>
>  
>
> **提示：**
>
> - `n == score.length`
> - `1 <= n <= 104`
> - `0 <= score[i] <= 106`
> - `score` 中的所有值 **互不相同**

```javascript
/**
 * @param {number[]} score
 * @return {string[]}
 */
var findRelativeRanks = function(score) {
    var scoreIndex = score.map(function(s,i){
        return [s,i];
    });
    var result = new Array(score.length);
    scoreIndex.sort(function(a, b) {
    return b[0] - a[0];
    });

    for(var i= 0;i< scoreIndex.length; i++){
        var index = scoreIndex[i][1];
        if(i===0){
            result[index] = "Gold Medal";
        }else if(i === 1){
            result[index] = "Silver Medal";
        }else if(i === 2){
            result[index] = "Bronze Medal"
        }else{
            result[index] = (i+1).toString();
        }
    }
    return result;
};
```

## 完美数

> 对于一个 **正整数**，如果它和除了它自身以外的所有 **正因子** 之和相等，我们称它为 **「完美数」**。
>
> 给定一个 **整数** `n`， 如果是完美数，返回 `true`；否则返回 `false`。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num = 28
> 输出：true
> 解释：28 = 1 + 2 + 4 + 7 + 14
> 1, 2, 4, 7, 和 14 是 28 的所有正因子。
> ```
>
> **示例 2：**
>
> ```
> 输入：num = 7
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - `1 <= num <= 108`

```javascript
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function (num) {
    if(num === 1){
        return false;
    }
    var bool = false;
    var arr = [];
    var index = Math.floor(Math.sqrt(num));
    for (var i = 1; i <= index; i++){
        if (num % i === 0) {
            arr.push(i);
            if (i != 1) {
                arr.push(num / i);
            }
        }
    }
    var temp = 0;
    console.log(arr);
    for (var i = 0; i < arr.length; i++){
        temp += arr[i];
    }
    console.log(temp);
    if (temp === num) {
        bool = true;
    }
    return bool;
};
```

## 岛屿的周长

> 给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。
>
> 网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
>
> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)
>
> ```
> 输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
> 输出：16
> 解释：它的周长是上面图片中的 16 个黄色的边
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [[1]]
> 输出：4
> ```
>
> **示例 3：**
>
> ```
> 输入：grid = [[1,0]]
> 输出：4
> ```
>
>  
>
> **提示：**
>
> - `row == grid.length`
> - `col == grid[i].length`
> - `1 <= row, col <= 100`
> - `grid[i][j]` 为 `0` 或 `1`

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function (grid) {
    var result = 0;
    // var arr = [];
    for (var i = 0; i < grid.length; i++) {
        for (var j = 0; j < grid[i].length; j++) {
            if (grid[i][j] === 1) {
                result += 4;
                if (i > 0 && grid[i - 1][j] === 1) {
                    result -= 2;
                }
                if (j > 0 && grid[i][j - 1] === 1) {
                    result -= 2;
                }
            }
        }
    }
    return result;
};
```

## 罗马数字转整数

> 罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
>
> ```
> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000
> ```
>
> 例如， 罗马数字 `2` 写做 `II` ，即为两个并列的 1 。`12` 写做 `XII` ，即为 `X` + `II` 。 `27` 写做 `XXVII`, 即为 `XX` + `V` + `II` 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：
>
> - `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
> - `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 
> - `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。
>
> 给定一个罗马数字，将其转换成整数。
>
>  
>
> **示例 1:**
>
> ```
> 输入: s = "III"
> 输出: 3
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "IV"
> 输出: 4
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "IX"
> 输出: 9
> ```
>
> **示例 4:**
>
> ```
> 输入: s = "LVIII"
> 输出: 58
> 解释: L = 50, V= 5, III = 3.
> ```
>
> **示例 5:**
>
> ```
> 输入: s = "MCMXCIV"
> 输出: 1994
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 15`
> - `s` 仅含字符 `('I', 'V', 'X', 'L', 'C', 'D', 'M')`
> - 题目数据保证 `s` 是一个有效的罗马数字，且表示整数在范围 `[1, 3999]` 内
> - 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
> - IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
> - 关于罗马数字的详尽书写规则，可以参考 [罗马数字 - 百度百科](https://baike.baidu.com/item/罗马数字/772296)。

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function (s) {
    var map = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    };
    var result = 0;
    for (var i = 0; i < s.length; i++) {
        var current = map[s[i]];
        var next = map[s[i + 1]];

        if (next && current < next) {
            result -= current;
        } else {
            result += current;
        }
    }
    return result;
};
```

## 检测大写字母

> 我们定义，在以下情况时，单词的大写用法是正确的：
>
> - 全部字母都是大写，比如 `"USA"` 。
> - 单词中所有字母都不是大写，比如 `"leetcode"` 。
> - 如果单词不只含有一个字母，只有首字母大写， 比如 `"Google"` 。
>
> 给你一个字符串 `word` 。如果大写用法正确，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：word = "USA"
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：word = "FlaG"
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - `1 <= word.length <= 100`
> - `word` 由小写和大写英文字母组成

```javascript
/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
    // 如果整个单词都是大写
    if (word === word.toUpperCase()) {
        return true;
    }
    // 如果整个单词都是小写
    if (word === word.toLowerCase()) {
        return true;
    }
    // 如果只有第一个字母大写，其余都是小写
    if (word[0] === word[0].toUpperCase() && word.slice(1) === word.slice(1).toLowerCase()) {
        return true;
    }
    // 其他情况返回 false
    return false;
};
```

## 最长的特殊序列I

> 给你两个字符串 `a` 和 `b`，请返回 *这两个字符串中 **最长的特殊序列*** 的长度。如果不存在，则返回 `-1` 。
>
> **「最长特殊序列」** 定义如下：该序列为 **某字符串独有的最长**
>
> **子序列**
>
> **（即不能是其他字符串的子序列）** 。
>
> 
>
> 字符串 `s` 的子序列是在从 `s` 中删除任意数量的字符后可以获得的字符串。
>
> - 例如，`"abc"` 是 `"aebdc"` 的子序列，因为删除 `"a***e***b***d\***c"` 中斜体加粗的字符可以得到 `"abc"` 。 `"aebdc"` 的子序列还包括 `"aebdc"` 、 `"aeb"` 和 `""` (空字符串)。
>
>  
>
> **示例 1：**
>
> ```
> 输入: a = "aba", b = "cdc"
> 输出: 3
> 解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。
> ```
>
> **示例 2：**
>
> ```
> 输入：a = "aaa", b = "bbb"
> 输出：3
> 解释: 最长特殊序列是 "aaa" 和 "bbb" 。
> ```
>
> **示例 3：**
>
> ```
> 输入：a = "aaa", b = "aaa"
> 输出：-1
> 解释: 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。
> ```
>
>  
>
> **提示：**
>
> - `1 <= a.length, b.length <= 100`
> - `a` 和 `b` 由小写英文字母组成

```javascript
/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
var findLUSlength = function(a, b) {
    return a !== b ? Math.max(a.length,b.length): -1;
};
```

## 第三大的数

> 给你一个非空数组，返回此数组中 **第三大的数** 。如果不存在，则返回数组中最大的数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：[3, 2, 1]
> 输出：1
> 解释：第三大的数是 1 。
> ```
>
> **示例 2：**
>
> ```
> 输入：[1, 2]
> 输出：2
> 解释：第三大的数不存在, 所以返回最大的数 2 。
> ```
>
> **示例 3：**
>
> ```
> 输入：[2, 2, 3, 1]
> 输出：1
> 解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
> 此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 104`
> - `-231 <= nums[i] <= 231 - 1`
>
>  
>
> **进阶：**你能设计一个时间复杂度 `O(n)` 的解决方案吗？

能出结果就行,别要求太高,太高就不礼貌了

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var thirdMax = function(nums) {
    var arr = nums.sort((a, b) => a - b);
    console.log(arr);

    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) === -1) { // 检查新数组中是否存在该元素
            newArr.push(arr[i]); // 如果不存在，添加到新数组中
        }
    }
    console.log(newArr);
    if (newArr.length >= 3) {
        return newArr[newArr.length - 3];
    } else {
        return newArr[newArr.length - 1];
    }
};
```

## 字符串相加

> 给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。
>
> 你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。
>
>  
>
> **示例 1：**
>
> ```
> 输入：num1 = "11", num2 = "123"
> 输出："134"
> ```
>
> **示例 2：**
>
> ```
> 输入：num1 = "456", num2 = "77"
> 输出："533"
> ```
>
> **示例 3：**
>
> ```
> 输入：num1 = "0", num2 = "0"
> 输出："0"
> ```
>
>  
>
>  
>
> **提示：**
>
> - `1 <= num1.length, num2.length <= 104`
> - `num1` 和`num2` 都只包含数字 `0-9`
> - `num1` 和`num2` 都不包含任何前导零

```javascript
/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var addStrings = function (num1, num2) {
    var str = '';
    var newNum1 = num1.split("").reverse().join("");
    var newNum2 = num2.split("").reverse().join("");
    var carry = 0; // 用于存储进位
    var len = Math.max(newNum1.length, newNum2.length); // 获取最长的长度
    var result = [];

    for (var i = 0; i < len; i++) {
        var digit1 = i < newNum1.length ? parseInt(newNum1[i]) : 0; // 如果长度不够，用0代替
        var digit2 = i < newNum2.length ? parseInt(newNum2[i]) : 0; // 如果长度不够，用0代替

        var temp = digit1 + digit2 + carry;
        if (temp > 9) {
            carry = 1;
            temp = temp - 10;
        } else {
            carry = 0;
        }
        result.push(temp);
    }

    if (carry > 0) { // 如果最后还有进位，添加到结果中
        result.push(carry);
    }

    str = result.reverse().join("");
    console.log(str);
    return str;
};
```

## 字符串中的单词数

> 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
>
> 请注意，你可以假定字符串里不包括任何不可打印的字符。
>
> **示例:**
>
> ```
> 输入: "Hello, my name is John"
> 输出: 5
> 解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
> ```

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var countSegments = function(s) {
    var count = 0;
    var arr = s.split(" ");
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] !== "") {
            count++;
        }
    }
    return count;
};
```

## 排列硬币

> 你总共有 `n` 枚硬币，并计划将它们按阶梯状排列。对于一个由 `k` 行组成的阶梯，其第 `i` 行必须正好有 `i` 枚硬币。阶梯的最后一行 **可能** 是不完整的。
>
> 给你一个数字 `n` ，计算并返回可形成 **完整阶梯行** 的总行数。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg)
>
> ```
> 输入：n = 5
> 输出：2
> 解释：因为第三行不完整，所以返回 2 。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)
>
> ```
> 输入：n = 8
> 输出：3
> 解释：因为第四行不完整，所以返回 3 。
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 231 - 1`

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var arrangeCoins = function(n) {
    if(n === 1){
        return 1;
    }
    if(n === 3){
        return 2;
    }
    var count = 0;
    for (var i = 1; i < n; i++){
        count += i;
        if (count > n) {
            count = i - 1;
            break;
        }
    }
    return count;
};
```

当然上面的方法不好,我准备修改一下

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var arrangeCoins = function(n) {
    var count = 0;
    for (var i = 1; i <= n; i++){
        n -= i;
        if (n < 0) {
            break;
        }
        count++;
    }
    return count;
};
```



## 反转字符串II

> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。
>
> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "abcdefg", k = 2
> 输出："bacdfeg"
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "abcd", k = 2
> 输出："bacd"
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 104`
> - `s` 仅由小写英文组成
> - `1 <= k <= 104`

```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
    var result = '';
    var arr = s.split("");
    for (var i = 0; i < arr.length; i += k * 2) {
        var temp = arr.slice(i, i + k).reverse().join('');
        result += temp + arr.slice(i + k, i + k * 2).join('');
    }
    return result;
};
```

## 种花问题

> 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。
>
>  
>
> **示例 1：**
>
> ```
> 输入：flowerbed = [1,0,0,0,1], n = 1
> 输出：true
> ```
>
> **示例 2：**
>
> ```
> 输入：flowerbed = [1,0,0,0,1], n = 2
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - `1 <= flowerbed.length <= 2 * 104`
> - `flowerbed[i]` 为 `0` 或 `1`
> - `flowerbed` 中不存在相邻的两朵花
> - `0 <= n <= flowerbed.length`

```javascript
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
    for (var i = 0; i < flowerbed.length; i++){
        var count = 0;
        var length = flowerbed.length;

        for (var i = 0; i < length; i++) {
            // 当当前位置为0，且前后位置也为0（或是边界情况）
            if (flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === length - 1 || flowerbed[i + 1] === 0)) {
                flowerbed[i] = 1;
                count++;
                if (count >= n) return true;
            }
        }

        return count >= n;
    }
};
```

## 分糖果

> Alice 有 `n` 枚糖，其中第 `i` 枚糖的类型为 `candyType[i]` 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。
>
> 医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 `n / 2` 即可（`n` 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。
>
> 给你一个长度为 `n` 的整数数组 `candyType` ，返回： Alice *在仅吃掉 `n / 2` 枚糖的情况下，可以吃到糖的 **最多** 种类数*。
>
>  
>
> **示例 1：**
>
> ```
> 输入：candyType = [1,1,2,2,3,3]
> 输出：3
> 解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
> ```
>
> **示例 2：**
>
> ```
> 输入：candyType = [1,1,2,3]
> 输出：2
> 解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。
> ```
>
> **示例 3：**
>
> ```
> 输入：candyType = [6,6,6,6]
> 输出：1
> 解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。
> ```
>
>  
>
> **提示：**
>
> - `n == candyType.length`
> - `2 <= n <= 104`
> - `n` 是一个偶数
> - `-105 <= candyType[i] <= 105`

```javascript
/**
 * @param {number[]} candyType
 * @return {number}
 */
var distributeCandies = function(candyType) {
    // 通过集合的方式,去掉重复出现的数字
    let candySet = new Set(candyType);
    // 满足医生的n/2
    let maxCandies = candyType.length / 2;
    // 求两者之间最小的数就行
    return Math.min(candySet.size, maxCandies);
};
```

## 最常见的单词

> 给你一个字符串 `paragraph` 和一个表示禁用词的字符串数组 `banned` ，返回出现频率最高的非禁用词。题目数据 **保证** 至少存在一个非禁用词，且答案 **唯一** 。
>
> `paragraph` 中的单词 **不区分大小写** ，答案应以 **小写** 形式返回。
>
>  
>
> **示例 1：**
>
> ```
> 输入：paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
> 输出："ball"
> 解释：
> "hit" 出现了 3 次，但它是禁用词。
> "ball" 出现了两次（没有其他单词出现这么多次），因此它是段落中出现频率最高的非禁用词。
> 请注意，段落中的单词不区分大小写，
> 标点符号会被忽略（即使它们紧挨着单词，如 "ball,"），
> 并且尽管 "hit" 出现的次数更多，但它不能作为答案，因为它是禁用词。
> ```
>
> **示例 2：**
>
> ```
> 输入：paragraph = "a.", banned = []
> 输出："a"
> ```
>
>  
>
> **提示：**
>
> - `1 <= paragraph.length <= 1000`
> - `paragraph` 由英文字母、空格 `' '`、和以下符号组成：`"!?',;."`
> - `0 <= banned.length <= 100`
> - `1 <= banned[i].length <= 10`
> - `banned[i]` 仅由小写英文字母组成

```javascript
/**
 * @param {string} paragraph
 * @param {string[]} banned
 * @return {string}
 */
var mostCommonWord = function(paragraph, banned) {
    let wordCount = {};
    let bannedSet = new Set(banned);
    let words = paragraph.toLowerCase().split(/\W+/).filter(word => word);
    
    for (let word of words) {
        if (!bannedSet.has(word)) {
            wordCount[word] = (wordCount[word] || 0) + 1;
        }
    }

    let maxCount = 0;
    let mostCommonWord = '';
    for (let word in wordCount) {
        if (wordCount[word] > maxCount) {
            maxCount = wordCount[word];
            mostCommonWord = word;
        }
    }

    return mostCommonWord;
};
```

## 字符的最短距离

> 给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。
>
> 返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。
>
> 两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "loveleetcode", c = "e"
> 输出：[3,2,1,0,1,0,0,1,2,2,1,0]
> 解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
> 距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
> 距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
> 对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
> 距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "aaab", c = "b"
> 输出：[3,2,1,0]
> ```
>
>  
>
> **提示：**
>
> - `1 <= s.length <= 104`
> - `s[i]` 和 `c` 均为小写英文字母
> - 题目数据保证 `c` 在 `s` 中至少出现一次

```javascript
/**
 * @param {string} s
 * @param {character} c
 * @return {number[]}
 */
var shortestToChar = function (s, c) {
    let cIndexes = [];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === c) {
            cIndexes.push(i);
        }
    }
    let result = [];
    for (let i = 0; i < s.length; i++) {
        let minDistance = s.length;
        for (let index of cIndexes) {
            minDistance = Math.min(minDistance, Math.abs(i - index));
        }
        result.push(minDistance);
    }
    return result;
};
```

## 跑圈

> 某人准备跑20圈来锻炼自己的身体他准备分多次(>1)跑完，每次都跑正整数圈，然后休息下再继续跑。为了有效地提高自己的体能，他决定每次跑的圈数都必须比上次跑的多 设第一次圈数不能小于0，那么请问他可以有多少种跑完这 20 圈的方案?输出方案总数，以及每种方案的排序。

```typescript
// 目标圈数常量
let count: number = 0;
const sum: number = 20;

/**
 * 递归查找所有可能的跑步方案
 * @param {number} countSum - 当前已跑的圈数总和
 * @param {number} lastNum - 上一次跑的圈数
 * @param {number[]} lastArray - 当前方案的跑步圈数组
 */
function findway(countSum: number, lastNum: number, lastArray: number[]): void {
    // 如果当前总圈数等于目标圈数，打印方案并计数
    if (countSum === sum && lastArray.length > 1) {
        count++;
        console.log(`${count}: ${lastArray.join('->')}`);
        return;
    }

    // 从上一次跑的圈数加 1 开始，尝试所有可能的圈数，直到达到目标圈数
    for (let i = lastNum + 1; i <= sum - countSum && i > 0; i++) {
        findway(countSum + i, i, lastArray.concat(i));
    }
}

/**
 * 主函数，启动递归查找方案
 */
function main(): void {
    findway(0, 0, []);
    console.log(`${count}种方法`);
}

// 调用主函数
main();
```

## 最大三角形面积

> 给你一个由 **X-Y** 平面上的点组成的数组 `points` ，其中 `points[i] = [xi, yi]` 。从其中取任意三个不同的点组成三角形，返回能组成的最大三角形的面积。与真实值误差在 `10-5` 内的答案将会视为正确答案**。**
>
>  
>
> **示例 1：**
>
> ![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png)
>
> ```
> 输入：points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
> 输出：2.00000
> 解释：输入中的 5 个点如上图所示，红色的三角形面积最大。
> ```
>
> **示例 2：**
>
> ```
> 输入：points = [[1,0],[0,0],[0,1]]
> 输出：0.50000
> ```
>
>  
>
> **提示：**
>
> - `3 <= points.length <= 50`
> - `-50 <= xi, yi <= 50`
> - 给出的所有点 **互不相同**

```typescript
function largestTriangleArea(points: number[][]): number {
    let maxArea:number = 0

    const area = (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): number=>{
        return Math.abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)) /2
    };

    for (let i = 0; i < points.length; i++) {
        for (let j = i + 1; j < points.length; j++) {
            for (let k = j + 1; k < points.length; k++) {
                const a = area(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]);
                maxArea = Math.max(maxArea, a);
            }
        }
    }

    return maxArea;
};
```





























# 框架

   ```javascript
   ```
